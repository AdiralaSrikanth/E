D22
what is Node js
Before the introduction of node js, at that point javascript really run in browser.
and limited to browser allowed to do. click event to button, redirect user to other page etc
creating webserver, connecting db was not possible
with the introduction of node js, developers can use javascript on the server side,
creating webservers, application backend and command line applications

D23
Summary from nodejs official page. 
Node js is a Javascript runtime built on chrome's v8 javascript engine.
every browser has their own js engine. nodejs uses chrome v8 js engine.

Job of any js engine is to take in javascript code and compile to machine code.
v8 is written in c++ lang.
anyone can write c++ app, incorporate v8 javascript engine into their app and
extend the functionalities that JS provide.

chrome and v8 do the same. chrome and nodejs are largely written in c++.
nodejs is a js runtime. It is not a programming lang. we write js code.

runtime provides custom functionalities- various tools and libraries specific to an environment

chrome provides V8 with various objects and functions. that allow js dev in the chrome browser to do things, add click events and manipulate dom
node doesnt provide those instead
node runtimme provides tools/libraries that node dev need. libraries for setting up server,
integrating with file system so that you can read and write from disc.

At the end of the day, both chrome and node are creating modified version of javascript

chrome browser uses v8 engine. when chrome needs to run a js for a particular webpage it does not run the javascript itself and It can't
instead it uses v8 engine to get that done.
It passes js code to v8 and it gets the results back.

It is also same with node. node doesnt know how to run js code. it passes to v8 and get the results

v8 does not know how to interact with DOM and filesystem. Its node and chrome job to provide implementations
for those when running v8.

chrome, node are written in C++ its not a coincidence

JS (chrome)             C++
localStorage.getItem   some C++ function
document.querySelector some C++ function

localStorage and querySelector are not part of Javascript lang. 
These are implemented by chrome run time. 
when chrome run a js file which has these methods, 
in the end of the day some C++ program is executed behind the scenes.

chrome tells v8 to do something when these methods are called. Chrome not only sending javascript code to v8
it also sends c++ code (C++ bindings - localStorage etc methods)to get the job done.

Same with node js.

Javascript (node js)   C++
fs.readFile             some c++ func.
os. platform            some c++ func.
Above methods are not part of javascript lang. also v8 does not understand them.
Those functionalities are implemented by node which is written in C++, 
when v8 excute js file with those methods. v8 differs to node js c++ code to execute.

"test".toUpperCase()
Js code can be executed in console or in node repl. Will get the same results. provided by v8 engine

in console -window or document
will get methods. but when you type the same in node repl you will get error {undefined}
window is provided by chrome when running javascript in browser

simillarly we have variable called global in node and the other one is process object (will have prop and methods, one method is exit {process.exit()}). will have prop and methods. 
When you type them in console/browser will get error

why nodejs?
walmart, netflix, uber uses node in prod.
remainining statement from official nodejs page : Node js uses an event-driven, non blocking I/O model
that makes it light weight and efficient.

Nodejs package ecosystem, npm is largest ecosystem of open source libraries in the world

I/O - input output
communicate with machine that it is running on. ex: reading some data from a file on the filesystem
quering a db to fetch records for a given user
I/o operation takes time 
with nodejs we get non blocking io. can do other things while we are waiting for I/O operation

Non blocking code will not wait for IO operation results, it will start the other process and waits for IO operation result in background

*** Node module system
Importing Nodejs core modules

ex: console.log('abc'), doesnt require to load anything. global modules come along with installation

filesystem:
fs.writeFileSync {synchronous version}- allows write some data to a file on our filesystem from nodejs app

fs.writeFileSync('nameofthefile', 'datatowrite')  --
fs.writeFileSync('abc.txt', 'test123')  --gets error {fs is not defined} because we did not load file system in the file 

before the above step, type const fs = require('fs') ---inside require('modulename').
To load in node module system, call require function. 
require returns prop and methods from the fs module

if file exists it writes data in that file. if doesnt exist create new file n writes data. 
Overwrites the data if we write some more data
use appendFileSync to append the data in file instead of Overwriting the data.

D24 - ***Notes app
Importing your modules:
define a function in utils.js and import it in app.js

use require('./utils.js) ---this file executes first then app.js

./ relative path to that file

every file has it own scope. we cannot access variables directly. 
we have to export var/methods from the file using module.exports. It returns something

**Importing npm modules:
validating data like email, sending an email. we dont have to reinvent wheel again
there are npm libraries which can do above tasks

npm comes along with Nodejs.

1. initialize npm in our project - 
creates one configuration file, we can use it to manage dependencies.

creates package.json file.

install validator library.
validator: library validates and sanitizes strings only.

npm i validator
when we run above command , goes to npm servers, grabs all of the code for that pkg 
and adds it to our application. 

node_modules folder is created. contains all of the code for the dependencies that we install.
pkglock.json - contains extra info making npm bit faster and secure. lists exact version of dependencies
where they fetched from. shaw code...

load in module using require
validator.isEmail('foo@bar.com') //true/false
isUrl('https://www.google.com') //true/false

node_modules directory is imp. when you do require(''), its gonna look in that node_modules folder
else we will get error cannot find module validator etc

npm install - it looks at pkg and pkglock.json to determine which dependencies our proj is using.
it creates node_modules from scratch.

--> for large project node_modules can be bigger so delete it while sharing it with friend.
your friend should type npm install to get all of the dependencies required to run the proj.

chalk -- color tool.

All the previous libraries are locally installed. Ex: validator and chalk libraries/modules

Global module
npm i nodemon -g ===> -g flag install module globally, at the os level
we do not have to use require to load in module in file.

Run the script like we normally do node app.js but use nodemon app.js

restarts the server for every save

D25
command line arguments
****Getting input from users

process is a object provided by nodejs runtime. contains methods and properties.
All the command line arguments are stored as a property in process.

node app.js test
test is stored under process
process.argv - (argument vector). It is an array contains all the arguments provided

when you type in node app.js add
console: returns array with values
1. path to node executable(nvm) in ur machine
2. path of the executed file.
3. passed argument
process.env[2] -- grabbing the 3rd value by index. if we pass argument and to get that argument value which is here - add
use this argument "add" and perform operation in file.
likewise sub/mul etc.

we can add more information. lets say user wants to add a note along with the title or
user want to delete note based on title.

node app.js add --title="this is my note"
--title is command line options
it gets stored as it as --title="this is my note" in process.argv property
it is not parsed. we cannot get --title value directly we will have to write code for it but we
do not have to reinvent the wheel. we can use 'yargs' library to parse arguments

yargs
npm i yargs
require('yargs') in ur app.
console.log(process.argv)
console.log(yargs.argv)

type in console : node app.js add --title: "this is my note"

yargs output: {_: ['add'], title: 'Things to buy', '$0': 'app.js'}
notice that title is parsed.
 _: is the array of passed commands
 title: 
 $0 - file that is executed.

 //add,read,remove, list.

 //add command
//we can achieve it using command method in yargs. it takes object
 yargs.command({
 })
 1. name command - add/edit etc and description of that command
 yargs.command({
     name: 'add',
     describe: 'add a new note'
 })
 2. add 'handler' command that is actually going to run when user uses 'add' command
 It's value is a function.
yargs.command({
     name: 'add',
     describe: 'add a new note',
     handler: function(){
         console.log('adding a new command')
     }
 })

when you type - node app.js --help,
it will show add command as available commands along with the description.

***Add command needs title and body to add a note
***delete command needs title to remove the Notes

we need to use the options
builder: {} takes object as value, in that we can define the options

yargs.command({
     name: 'add',
     describe: 'add a new note',
     builder: {
         title: {
             describe: "Note title",
             demandOption: true //by default it is false. we can set to true. 
                                //bascially telling that this option is required/mandatory.
                                //if we type node app.js add --without title option/argument, it 
                                throws error Missing required argument: title 
            type: 'string' //if we dont specify type, by default it is true
                            //node ap.js add --title results in true when you set type it changes it to string
         }
     }
     handler: function(argv){ //when you define options, those are accessible in handler as argv
         console.log('adding a new command', argv) //prints available/enetered arguments
                                                    //argv.title --gets the title value
     }
 })
At the end of the file we need to set ******yargs.parse() so that yargs parses all the commands.
this is also can be done using yargs.argv

Adding body option
yargs.command({
     name: 'add',
     describe: 'add a new note',
     builder: {
         title: {
             describe: "Note title",
             demandOption: true, 
            type: 'string'
         },
         body: {
             describe: 'Note body',
             demandOption: true,
             type: 'string'
         }
     }
     handler: function(argv){ 
         console.log('accessing notes body', argv.body) 
     }
 })

**Storing data with json:
We need to store notes, when a user adds a note today and comes 2mrw to edit/delete/read note
we use fs module to store notes to file. data going to that file is JSON data

JSON has native support in javascript. will learn about json now.
create a js object
 const book = {
     title: 'The untold hearts',
     author: 'Md. Ravoof'
 }
convert it to json which is a string. fs core module only knows how to work with string data

JSON.stringify(array/object) -- converts to json string representation.

const bookJSON = JSON.stringify(book)
console.log(bookJSON.title) //you will get undefined, we cannot access json string value (converted from obj to json string)

JSON - js object which has both prop and value as strings.

const bookObj = JSON.parse(bookJSON) // takes json and converts it to object
console.localStorage(bookObj.title) //gets the title value

Now, we will write data to file using fs core module. we use writeFileSync method.

const bookJSON = JSON.stringify(book)
fs.writeFileSync('1-json.json', bookJSON) //stores bookJSON data to the file.

Load JSON data::::::
const bufferData = fs.readFileSync('1-json.json') //returns content of the file

here bufferData is because data is not retrieved in the form of string, 
it return in the form of chunks/buffer.
<buffer 7b 55 48 75 12 >    bits/bytes Binary data.

use toString() to get the actual data.

const bufferData = fs.readFileSync('1-json.json')
const datajson = bufferData.toString()
const data = JSON.parse(datajson) // converts json string data to object
console.log(data.title) //prints title
 
try-catch block:
try{
}catch(e) {,
}
if there is an error in try block, immediately stops and runs catch block.
put readFileSync code in try block, if there is no file to read, it goes to catch block 

Arrow functions::::::

const square = function(x) {
    return x * x
}
console.log(square(3)) //9

Above function can be rewritten in arrow function
1. const square = (x) => {
    return x * x 
} 
we do not need function keyword instead use () and => arrow

2. if we have only one return statement then we can omit return keyword and {}
const square = (x) => x * x 

Arrow function in methods:

const event = {
    name: 'Birthday party',
    printGuestList: function(){
        console.log('guest list for' + this.name) //we can access obj prop's under obj method using this keyword.
    }                                           //this is reference to the obj.
}
event.printGuestList()

for the above example if we use arrow function 
    name: 'Birthday party',
    printGuestList: ()=> {
        console.log('guest list for' + this.name) //we will get undefined
    }  
arrow function do not bind their this value. 

****Arrow functions aren't suited for methods when you want to access this. best case is to use normal func

or we can use es6 shorthand syntax.

name: 'Birthday party',
    printGuestList(){
        console.log('guest list for' + this.name) //we will get the correct ans.
    } 
*** Why we want to use arrow function.

const event = {
    name: 'Birthday party',
    guestList: ['andi', 'mike', 'test']
    printGuestList: function(){
        console.log('guest list for' + this.name)

        this.guestList.forEach(function (guest){
            console.log(guest + 'attending' + this.name )
        })
    }                                        
}

output: 
in the loop:
andi attending undefined
mike attending undefined
because 1. normal func bind their this value
solution:
1. arrow func do not bind their this value

filter vs find.
if we are checking for duplicates in an array (1000records), and the duplicate match is at 89record
filter function finds at 89 record and loops till 1000 where
find function finds record at 89 and stops/return the execution. {undefined if it do not find}

D26
Skipping weather app for now.

install mongodb , robo 3t - follow configuration videos.
***database needs to be in running in order us to connect.

mongodb.com>docs>mongodb drivers> node js driver.

Drivers are libraries that allow you to interact with mongodb database from a wide range of prog. lang.

1. Create task-manager app folder and do npm init
2. install mongodb - npm i mongodb
Generates node_modules folder. from here we are actually ready to use
the driver to connect to our database and insert some documents.

** const mongodb = require('mongodb')
returns object. on that object, one thing we need to initialize the connection.

known as mongo client

MongoClient = mongodb.MongoClient

gives the function neccessary to connect to the ddatabase so that we can perform crud operations

D29 - revised above content from beginning. 
continuing the course - webapp.

D30
Debugging Nodejs.
Everyone who is writing software making mistakes, the real goal is to recover 
them quickly and get back on track so we can work on continue to be productive.

1. console.log()
2. debugger

use "debugger" text in between the script. halts the execution on that line.
we need to use inspect command like "node inspect filename" to use debugger.
In the console it shows like debug>

Now open chrome browser and type chrome://inspect

node debugger uses built in v8 debugger tools also chrome uses same debugger v8 tools. other browser
debugger tools will be different.

Remote target: click on inspect, opens new instance.
if you dont see ur app under remote target. click on configuration and check localhost and ip 
if those two fields are not there then add localhost:9229 and 127..0.1.9229.

Notice that nodejs scripts are wrapped inside a function.
In other prog lang, you will have main func which executes first. In node js we do not have it
node considers it as main func and provides required or another files.

import files to chrome inspect. Loads every file.
Click on play button to resume execution. script halts on the line where we mentioned debugger

Under scope tab we can see all the variables and values
In the console you can get the values of the variables ex: notes[1] , grabs the index of 1 value from notes array

click on play button it continues all the statements in the script and finishes the execution.

to restart the execution again, type in restart command and to shut down the process by control c.

Logic errors -Debugging helps
When you do typo errors, 
Stack trace
Reference error : datajspn is not defined //gives you the info of the error.

next to it, it gives the file name where error occured. 
at saveNotes (//path of the file: line no and column number) 
Next lines gives you, where exactly this method called
(here saveNotes called in add Notes and add notes called in handler)

*****Nodejs
    Asynchronous
    Non blocking
    single threaded
    event driven

console.log('starting')

//Asynchronous func which node js provided
setTimeout() - allows to run some code after specific amount of time passed.
takes two arguments. first argument is the function and the second is of time in milliseconds

setTimeout(()=>{
    console.log('setTimeout -2secs timer')
}, 2000)

2000 milli seconds - 2secs, we are telling that wait for 2secs and then run the func.
console.log('stopping')

In the synchronous model, the order of execution is one by one 
i.e 1. starting 2. 2secs timer (here code waits for 2secs - halts execution for 2secs) 3. stopping

if we are performing any IO operation, querying db and getting a record of a user, it takes lot of time
till that time we are unable to perform other operations.

whereas in Asynchronous node js, the order we gonna get is
1 starting
(here 2secs timer process starts and do not halt the execution)
2. stopping (waits for 2secs)
3. 2secs timer gets printed.

Consider the below example
console.log('starting)
setTimeout(()=>{
    console.log('0 sec timer)
}, 0)
console.log('stopping)

output : 1. starting 2. stopping 3. 0 sec timer

why is it 0 secs timer is printed at last (not printed in second)?
we have to understand, the internals of node js that are responsible for getting asynchronous programming
to work.

Node js file has the following code

const x = 1
const y = x + 2
console.log('sum is ' + y)

above code is of synchronous code example, lets see the execution process.

Call Stack is a data structure provided by js v8 engine. The job of the call stack is to track the 
execution of our program. It does by tracking all the functions that are currently running.

FIFO - first in first out. (Ex: tennis ball tin, you add balls in it and when you want to
remove last ball you will have to remove the first one first.)

will see the above code snippet execution,

first thing nodejs do is wrap all the code of our script inside a function. {other prog lang's
have a main func nd that main func is executed first, in nodejs we do not have main func, nodejs
itself creates/wraps our code into a function and that function is executed
} 

1. Main func is pushed into call Stack
If something is added to call stack then it is going to execute
we created const x with value 1 and other const y with value x + 2 ,i.e 3

console.log('sum is ' + y)

log is a func and whenever there is a func call it gets added to call stack.

2. log('sum' + y), then it is going to execute and get executes and prints value in console
after execution of log method it pops out of the Stack

3. Moves to next line of the program. here there is no code after the console.log('').

so the main func is pop-ed out of the call stack.

Example 2:
const listLocations = (locations) => {
    locations.forEach((location)=>{
        console.log(location)
    })
}
const myLocations = ['philly', 'nyc']

listLocations(myLocations)

1. Main func is pushed into call stack - this allows to start script execution
2. first line of above code - listLocations is a function but it is not func call, so it 
   is not going to add it to call stack now.
3. defined myLocations and assigns value which is array
4. comes to last line listLocations(myLocations), here it is a func call so its gets add to call stack

Now call stack looks like below
listLocations(myLocations)
main()

listLocations([...]) is in call stack now so the listLocations func execution starts

There is func inside the listLocations func
    i) forEach gets added to call stack
        a) anonymous func(inside forEach - callback) gets added to call stack 
        b) console.log - log is a function call , adds it to call stack
            i) prints first location from the array to console
        c) anonymous func pops out of the call stack

    Going to repeat the step a) for remainining elements in the array. after finishing
    all the elements in array forEach pops out.

Once the forEach func is poped out, listLocations is also pops out from call stack because no other lines are there inside
listLocations func.

After listLocations pops out, main func pops out as there are no other functions to execute.

Example 3 : Asynchronous code snippet.

The output we saw for the below code is
1. starting
2. stopping
3. 0 sec timer
4. 2 sec timer

2secs timer is getting executed after all functions is fine because we are putting 2sec delay in execution
but why is 0 sec timer is getting executed after stopping? why is it not getting print in second line

console.log('starting)

setTimeout(()=>{
    console.log('2 sec timer)
}, 2000)

setTimeout(()=>{
    console.log('0 sec timer)
}, 0)

console.log('stopping)

Execution process: 
1. main func pushed into call stack
2. log func is pushed into call stack and executes and prints "starting" message to console.
removed from call stack after the execution.

3. setTimeout is a func, observe setTimeout() - func call, inside it has another func but it is first a func call
as setTimeout is func call it is pushed into call stack.

setTimeout is not part of Javascript programming language. Not gonna find it in JS spec and 
V8 has no implementation for it.

instead it is node js which creates an implementation of setTimeout using c++ and provides
to nodejs scripts to use.

when we call setTimeout, it is registering an event with nodejs api's. that is an event call back pair.

event here is to wait 2 secs
and callback is the func to run
callback excutes when the timer of 2secs finishes.

when you call setTimeout, a event is register with node apis, 
and will have setTimeout callback waiting for 2secs. the process of 2secs gets started

while we are waiting for that 2 secs to finish, we can do other things.
Javascript is single threaded programming language. You can do one thing at a time and the call stack
enforces that. first one in call stack gets executed first, no way to execute multiple things at same time

it doesnt mean Node js is completely single threaded. code you run is single threaded but nodejs
uses other threads in C++ behind the scenes to manage events. 
this allows us to run our app while we are waiting for 2secs. we dont have to wait for complete 2secs
it is non blocking nature of node. not blocking rest of the app to run. {setTimeout example}

Summary : when you call setTimeout, call stack registers event with node apis and 2secs timer here gets started. 
{event-callback pair, callback func excutes after the event. here event is 2secs }

4. execution moves to next line. another setTimeout func call. follows same steps as step 3

5. Nodeapis, callback queques, event loop.

all the registered event-callback pair moves to node apis
callback queque - after finishing the event {2sec timer or 0 secs timer}
, callbacks are moved to callback queque

job of callback queque is to list all the callbacks

job of event loop is to get the first callback from callback queque and push to call stack when call stack is empty.

here call stack is not empty, main func is there so event loop do not push callbacks from callback queque to call stack.
execution moves to next line

6. console.log('stopping'), log moves to call stack, executes and prints to console.

7. after finishing the log, there are no func. calls left so main func pops out.

8. now the call stack is empty, now event loop comes into picture. it now looks into callback queque for any callbacks,
we have two callbacks in callback queque 1. setTimeout 0 secs n 2. setTimeout 2 secs

eventloop pushes first setTimeout 0secs to call stack, callstack execute it and prints 0 secs and pops out 0secs setTimeout

next eventloop pushes setTimeout 2secs to call stack , callstack execute it and prints 2 secs and pops out 2secs setTimeout

Code execution finishes now.

****Making HTTP requests.
make http requests from nodejs application.

1. If you want to get whether data into your app, you gonna have to make http request.
2. If you want to send email to someone from your app, its gonna another http request
3. if you want to send someone a text message using twilio , that is also a http request.

our app server doing http request to some other company server to get some task done.

Darksky.net/dev --api
application gives forecast based on coordinates. 

signup in the app. app gives secret key. 
this key helps app developers to track the requests made by the user, limit: 1000requests/per day for one user

sample api call : url/secretkey/lat,long ---returns json with weather information. 
JSON is the standard data while exchanging data between the services

we will make this api call from our nodejs app.

To make http requests, we can use core nodejs modules to make http request but they 
are very low level. You will have to write lot of code to get things done.

we will use npm module that is wrapper around core modules and make it easier and more streamlined process to make http requests

npm init
install request module from npm. 
npm i request {dependency gets installed under node_modules}

const request = require('request')

request({}, ()=>{})
request takes two argyments
1. options object, where we pass options here in this case url - api
2. call back, it executes when we get some respone/data. callback takes two arguments
    a) error, if something goes wrong from that api {ex: you are not connected to internet or wrong api url etc}
    b) response obj, if we succesfully hit the api and api returns the data.
request({url: url}, (error, response)=>{ // if we get correct respone then error value is undefined
    console.log(respone)
})

data gets in the form of json, convert json to obj using JSON.parse(respone.body)-->body prop has required data

***we can parse json in request module itself. pass json: true in request options object

install json formatter plugin in chrome and add extension.

****To add options to the url, we have to url/lat,long?key=value&key=value
ex:lang=it&units=si ---> response comes in italian and units in si units. 

We have hardcoded the lat and long in darksky api but in our web app user enter 
location and gets the forecast. we need another api which takes in location
and gives the cordinates.

Geocoding - takes location and gives the co ordinates.

we can use Mapbox api for geocoding and pass the coordinates to Darksky api.

D31
signup - mapbox, gives access token, limit 50000 requests/month.

mapbox web services --> we are using Geocoding services {search service - Geocoding}

forward geocoding - address -> coordinates
reverse geocoding - cordinates -> address.

required parameters - endpoint and search_text
endpoint here - mapbox.places , mapbox.places-permananent (commercial/enterprise)

query string: ?key=value&key=value

Handling errors:
request({url:url}, (error, response)=>{
    if(error){
        console.log("unable to connect to ----service") //we get error when 1. we do not have internet connection. low level error
    }else if (respone.body.error){
        console.log('unable to find location') //something wrong in api url that we written - given wrong/removed cordinates. - input error
    }else {
        console.log(respone.body.features)
    }
})

CallBack function: A function passed as argument to another function. Intension to call later
setTimeout(()=>{

}, 2000)
Above example we are using callback in asynchronous way. setTimeout is node provided api
Not every callback func is asynchronous. array methods filter uses call back pattern but are indeed synchronous.

const names = ['andy', 'jes', 'jesp']
const shortnames = names.filter((name)=>{ //passing a callback func to func, intension to call later
    return name.length <= 3
})
we are using callback pattern in above example but there is nothing asynchronous. It is not reacting with native
node api.

we can create our own callback functions.

const geoCode = (address, callback) => {
    const data = {
        lat: 0,
        long: 0
    }
    return data
}
const cordinates = geoCode('philly')

usually if we want to get data object when we call geocode func is by returning data obj from geoCode func

but what if we have asynchronous func like setTimeout?

const geoCode = (address, callback) => {
    setTimeout(()=>{
        const data = {
        lat: 0,
        long: 0
    }
    return data
    }, 2000)
}
const cordinates = geoCode('philly')
This will not work, because we are returning from setTimeout func not from geoCode func.
also we are expecting to get the data from asynchronous func (setTimeout) in our synchronous func i.e main func
this wont happen because event loop pushes callback funcs only when callstack is empty. 

here we need to use callback func

const geoCode = (address, callback) => {
    setTimeout(()=>{
        const data = {
        lat: 0,
        long: 0
    }
    callback(data)
    }, 2000)
}
geoCode('philly', (geoCodeData)=>{ //when you call geoCode with philly as address - one argument and the
                                //other argument as callback func. it is not going to execute first
                                //callback func passed as argument, is going to execute under setTimeout func
                                // we are passing data obj as argument to callback func
                                //setTimeout callback trigger after the 2secs timer event finishes.

    console.log(geoCodeData)
})

callback under setTimeout gets called when the timer finishes and we can access data object 
in callbackfunc which is passed to geoCode. //update this para.

why are we using setTimeout under geoCode?? because we need to get the coordinates when we call geocode with location. 
this is done by doing http request to map box api which is asynchronous

so here the pattern of the example ---> under geocode func we make api request via http request to mapbox which is asynchronous one
and use callback to send coordinates. geocode returns cordinates via callback func and we use callback func in geocode func call to use those cordinates
and give forecast info to the user for that location

we will use callback in geocode func

callback abstraction: 
const geocode = (address, callback) => {
    const url = "url/+address+" //we can send diff address as we are using dynamic address

    request({url:url, json:true}, (error, respone)=> {
        if(error){
            callback('unable to connect to --service' , undefined) //instead of doing console.log, we are sending
                                                                // error message to callback func, so that callback func
                                                                //can do anything with that error/response --send error msg as email to client etc                                                 
        } else if(respone.body.features.length === 0){
            callback('unable to search location', undefined) //if there is no response it is automatically set to undefined but it is good approach to send undefined value for respone
        } else {
            callback(undefined, {
                lat: respone.body.features[0].center[1]
                long: respone.body.features[0].center[2]
                location: respone.body.features[0].place_name
            })
        }
    })
}
*****we cannot return under request method as it is asynchronous one so using callbacks

geocode('philly', (error, data)=> { //every callback is called with error and data
        console.log('Error', error)
        console.log('Data' , data)
})
pattern same with mapbox -- create separate files for geocode and forecast and require them in app.js

final version

geocode('philly', (error, data)=> { 
        console.log('Error', error)
        console.log('Data' , data)
})

forecast(70.11,44.154,(error, data)=>{
        console.log('Error', error)
        console.log('Data' , data)
})

callback chaining:
we are performing two asynchronous io operations. problem is they are operating independently.

we get the coordinates from geocode data object so pass them to forecast by calling forecast inside of geocode

geocode('philly', (error, data)=> { 
        if(error) {
            ***return console.log('Error', error) //return terminates the func. can skip else statement below if we use return
        } else {
            //console.log('Data' , data)
            const lat = data.lat
            const long = data.long

            forecast(lat,long,(error, forecastdata)=>{
                if(error){
                  return console.log('Error', error)
                }
                console.log(data.location) //location we get from data object when we execute geoCode
                console.log(forecastdata) //string text of forecast
            })
        }
})
es6 - objects
Object property shorthand. 

const name ='srk'
const userAge = 25

const user = {
    name: name,
    age: userAge,
    location: "hyd"
}
we are not using es6 object prop shorthand

we can use es6 object shorthand, when we are setting a property with value which comes from a variable with same name

ex: const user = {
    name,           //creates name prop and looks for name var and assigns name var value to name prop under obj
    age: userAge, //cannot use shorthand because names should match, here variable is userAge not age
    location: 'hh'
}

J1
Object destructuring : A object and you are trying to access object properties

const product = {
    label: 'Note book',
    price: 3,
    stock: 201,
    salesPrice: undefined
}
Can access obj prop as 
const label = product.label
const price = product.price

but we end up writing many lines of code, using latest syntax (object destructuring) we can create individual variables like

const {label, price} = product

creates individual variables label, price etc from product object.

console.log(label) //Note book

we can rename the variable names, by putting colon infront of obj prop. 
const {label:productLabel, price} = product

we can set default values to the variables

const {label, price, rating =5} = product

creates rating variable and assigns 5 as value. if rating is defined as prop under product object then
default values are not applicable.

destructuring can be used while passing obj as func arguments.

const transaction = (type, myProduct) => {
    const {} = myProduct
}

transaction('order',  product).

Instead of destructuring the object inside the method we can destructure on func argument itself.

const transaction = (type, {label, stock}) => { //we can access product obj properties label and stock
    console.log(label)
}
transaction('order',  product).

*****HTTP requests without a library {earlier we achieved http requests using request npm library}
libraries make process a lot easier.
 Learning what exactly request module is doing --

Navigate to node official documentation - 
we have two modules - http and https to perform standard and secure http request.
whereas using request npm library, we dont have to use two modules. request module abstracts all these behind the scenes

http and https - we can use these two modules to create server and make request to existing server

Geocode is a https request. Load in https module in our app. 
it is core module so we dont have to install anything.

const https = require('https')
https.request(url, (response)=> { //request module to fireoff request
                                 //takes two arguments, one url and another argument as callback
                                //callback takes one argument which is response {this we get when we hit url}

//core modules operate at low level, we get data in the form of chunks based on response not complete response at Once
//Listen to individual chunk to come in.

    response.on('data', (chunk)=> { //response.on() is a func that allows us to register a handler
                                    //we have diff events that we can register, here the event is data
                                    //callback fires when the new data comes in and can access the data by the argument chunk
    })

    response.on('end', ()=> { //when we get all the data this 'end' event gets fired
    })
})

the data we get in chunk is of buffer data and we get individual chunks based on the response that server is sending
we need to store in one var and then convert to string and then parse it object

--> use data and end events together - get the complete data json, parse it 

const https = require('https')
https.request(url, (response)=> { 
    let data = ''
    response.on('data', (chunk)=> { 
        data = data + chunk.toString() //we get multiple chunks (buffered data) so converting it to string and
                                        //storing it var data
    })
    response.on('end', ()=> { 
        const parsedObj = JSON.parse(data)
    })
})
the above do not work because we need to tell that we are ready to send final request(complete request) 
this is done by
request returns request object, store it in a variable
tell that we are done with request by calling end method

const https = require('https')
const request = https.request(url, (response)=> { 
    let data = ''
    response.on('data', (chunk)=> { 
        data = data + chunk.toString() //we get multiple chunks (buffered data) so converting it to string and
                                        //storing it var data
    })
    response.on('end', ()=> { 
        const parsedObj = JSON.parse(data)
    })
})

//before sending final request, we need to handle errors

request.on('error', (error)=> { //error event
    console.log(error)
})
request.end()

This is what it takes to send http and https requests using core modules.

core node modules are supposed to provide with low level implementations. node comes with npm bundle so we can use
npm modules.

what ever apps we build till now are accessible via CLI (notes app, partial weather app), but we
need to access them via url. user can enter url in the browser and can access our application.

webservers: express - npm library
express makes very easy to create webservers using node. 
serve up all the assets for webapp - html, css and client side JS

1. visit a url in the browser, to interact with ur app in the browser
node server - serves up browser with all of the assets to load - html,css, client side js and also images.
2. instead of serving up a website we could serve up http json based api {similar to mapbox or darksky api - exchanging jsondata back n forth with the server}

****
npm init
npm i express.

instead of putting all the files under root. create and put all the node files under src folder. Bit organised now.
or else it would be complex when you have more files when the app is scaled.

src-->app.js

const express = require('express')
return function, we call it to create express application.

const app = express()
//app.com --> homepage etc
//app.com/help
//app.com/about --->routes

setup our server to send a response when someone get something at specific route. we set that up by using get method.

app.get() //lets us configure, what the server should do when someone get the resource at a specific url. {may be we are
sending html or may be we are sending json}

app.get('/', (req,res)=> {  //get method takes two arguments 1. route - '' or '/' 2. callback, what we want to do/send back to them when someone visit the route
    
                    //callback takes two arguments 1.req, 2.res
                    //req obj - containing information about the incoming request to the server
                    //res - contains bunch of methods allowing us to customize what we gonna send back to the requestor.
    
    res.send('hello express') //sends to browser
})
we need to start the server. currently server is not up and running
to start the server
app.listen(3000, ()=>{ // starts the server and listen to specific port. common dev port - 3000, for http default-8080
                        //callback runs when the server is up and running. callback is optional.
})
node process is running, thats why cursor is still running not returned to terminal.
J2
localhost:3000 
when we visited that url in the browser, it went off to the server, the express server found the matching route
and returned the text response.

In reality we will not send string we either send json or html
HTML as res
res.send('<h1>This is some heading</h>') //html under string

JSON as res
res.send({         //json can be array of objects - [{},{}]
    name: "json"
})
express gonna detect that we provided an object, automatically stringify and renders json

We are adding a html inside a string in js file. It would be difficult to manage if we add more html elements in res.send
It would be nice if we add separate files and express server those files

configure express to serve up entire folder that would contain html,css, js and images 

Create a directory
public ---> anything under this folder served up as part of express server

public>index.html

index.html is a special file. by default servers serve index.html as root route.

Goal is to teach express how to serve up the contents of the directory, we need the path to the public directory.
It cant be a relative path but it needs be of absolute path from the root of ur machine.

Node provides two variables

1. __dirname -- gives the path of the directory
2. __filename -- gives the path of the file

These two values are provided by that wrapper func (debugger - main func created / wrapped all our code inside a func )
that func provides various things to our code like require func.

currently __dirname is ponting towards src/index.js we need to point to public folder.

we have a core node module "path" & has a method "join" - 

load core module -- const path = require('path')

path.join(__dirname, '../public') //join is a func and returns the final path. we send individual pieces it does manipulating the
paths/string

const publicDirectoryPath = path.join(__dirname, '../public')
app.use(express.static(publicDirectoryPath))

app.use() --> way of configure/customize ur express server.
express.static() --> serves public folder.

localhost:3000/index.html also works 

app.get('', ()=>{}) - root route is not needed now as we server up index.html in public folder, so server by default picks up that file

create css folder > css file and link it in all html files(use link tag under head tag). 

<link rel="stylesheet" href="/css/style.css">  //webserver root, here public folder
same with client js(script tag under body tag...<script src="/js/app.js"></script>) and images-img element <img src="/img/abc.png">.

./ --> relative path ->relative to that file
/ -> absolute path --> webserver root

J6
Dynamic pages with templating
J7
Dynamic pages with templating
static - do not change.

Template engine to render dynamic web pages using express

Handle bars:
1. gonna allow us to render dynamic document
2. easily create code that can be used across pages ex: header and footer, we can write once and use them in each page
It would be bad if the header and footer changes for each page and if we use copy paste the code in 
each page, it would be difficult to go to each page and modify.

npm handlebars
it is low level library that implements handlebars in js.
can be used in browser, server, desktop apps using electron 

we use handlebars using express server.

another handlebar plugin npm hbs. hbs uses handlebars behind the scenes. makes easy to integrate with express
install hbs in our proj.
npm i hbs

Now, we need to tell express which template engine we are using.

app.set('view engine', 'hbs') //hbs- name of the module
spacing and capitilization is important in view engine string.

By default express looks for templates under views directory
under views folder - create files - index.hbs (extension is hbs)

hbs are same as html with few added features like injecting dynamic values

to server up above file (index.hbs), we need to set up a route

app.get('', (req,res)=> {
    res.render('index', {title: "weather"})  //res.send() - can be used to send string, html string, obj and also array
                                //object is converted to json. express takes care of it
                            //instead of using res.send we used res.render() method, which renders our views and it takes two arguments
                        //res.render('template file', {object, these values are provided
                         as dynamic values which are used under index.hbs template file })
})                      //no need to adding .hbs extension to index, as long as name is equal, it is fine

when requestor comes to the home root. by calling res.render() express goes to views
and converts hbs to html and give html back to requestor.

the second argument we passed to res.render(), that can be accessible in index.hbs
To access title in index.hbs we use the syntax {{}}, inside inner bracket write variable/prop name
ex: {{title}} //title gets printed in browser

customizing views directory:
if you change the name of the views directory, express will through error as
"Failed to lookup view "help" in view directory ...points to directory where it expecting views directory to be"

by default express expects the location of views under root, we can customize it 
we need to tell express where to look

define one path just like we defined for publicDirectoryPath
const viewsPath = path.join(__dirname, '../templates'). now we need to tell express to use this path
app.set('views', viewsPath)

app.set(name,value)

resuable partials, that can be used in all documents (header and footer or sidebars)
partials - allows you to create little template of a bigger page

to work with partials we need to first load in hbs module in app.js
const hbs = require('hbs')
now we need to tell handlebar where to look in for partials.

create a folder under template folder - 1. views - move all views(hbs files) to this folder
2. create partials folder - put header.hbs and footer.hbs files under this folder.

***Change the views path ../templates/views

const partials = path.join(__dirname, '../templates/partials')
resgisterPartials method is used to tell hbs where to look for partials

hbs.resgisterPartials(partials) //method takes argument of partials files path directory.

header.hbs
it isnt a complete page, it is part of the page
we can create h1 tag <h1>Static header.hbs text </h1>
we can now use this partials-header file in all other views files

To render a partial in other pages:

{{>header}} ---> after greater than symbol put file name.

we get error because we are using nodemon and it restarts only when there is anychange in js files
we need to tell nodemon to restart server for changes in all hbs files.

customize nodemon command
nodemon src/app.js -e js,hbs ===>  we need to use -e flag, stands for extension 

now nodemon restarts for changes in js and hbs files.

remove {{title}} from all files and put partial {{>header}} 
now in header.hbs file we can now grab the title value from all pages, about,help and homepage

<h1>Static header.hbs text </h1> instead of using static value, use
<h1>{{title}}</h1> in header.hbs and load it in all views pages.

so when we use {{>header}} in about/help/homepage, it goes to header.hbs or loads that file in views pages

title value we are passing from routes to all pages, hence title value will be printed based on its value

we have header in place and we can add navigation bar in header.hbs

create a tag
<div>
<a href="/about">About</a> //href to specify where this link should go to
<a href="">Weather</a>  --home
<a href="/help">Help</a>
</div>
we you click on the link, it goes to appropriate routes and returns the respone.

By using partials we achieved headers and navigation bars by writing once and it is accessible in all pages
if we have to change anything, we can change in header.hbs file and it is applicable in all pages

create same for footer partial.
footer.hbs ==> <p>created by{{name}}</p> 
include it in all views pages ==> {{>footer}}

****404 Pages:
/me --some random route throws error as cannot GET/me  , error given by express
we can set 404 page when user provide wrong url 
1. we can render html with some message 
2. we can provide links to home/about etc

in app.js file define a route with * ---star is a wildcard
Define route with * at the bottom, above app.listen.

express matches with this route if express did not find any matching route when user navigated to page.
ex: /about - express matches with /about route and sends respone
/me - we do not have this route. express checks for this route from beginning of app.js file
it first checks with publicDirectoryPath did not find, then checks all the routes - did not match
at last we have * wildcard route, matches it and returns respone.

if we write * at the beginning express matches with it and returns respone though we have /about route in middle of the file

create a route with * wildcard

app.get('*', (req,res)=> {
    res.render('404page', {
        errorText: "Page Not found",
        title: "404 page",
        name: "srk"
    })
})
In the 404page.hbs add header and footer partials. header is taken from title prop which we sent.

if we have articles, /help/somearticlename, which do not exist, we can create a route /help/* and render help article not found message
and provide links to get back to other pages. {specific to help page}

v51,55 - comeback after css.

Accessing API from browser
creating own api endpoint and access them from browser.

we need browser to communicate with server by passing a location and server converts 
it to forecast and sends that forecast to browser as json respone and browser renders it to screen.

**The Query string::
?key=value&key=value

final output -- search form where user enter location and click on a button, after few milliseconds
user gets forecast data for that location.

/weather we are sending static json, the goal is to use geocode and forecast functions inside the /weather and send
json data to browser and browser will be able render the forecast data 

how browser gonna able to send location/address to /weather route.
/weather route should know which address it needs to geoCode and fetch forecast for.

for this we use query string. browser gonna send query string as part of url, server then read the query string
value and get the geoCode/forecast for that location.

url?key=value&key=value.

we create a /products endpoint and that sends back products to be displayed in the browser.

app.get('/products', (req,res)=> {
    res.send({
        products: []
    })
})
open the route /products in browser, it renders products json.

we can filter the products based on user search field.
ex: user can seach games and we should render games products in our ecommerce site.

we pass that search term as part of url - query string
localhost/products/?search=games

express parses the url and gives us a query object which will have the information about the query strings

app.get('/products', (req,res)=> {
    console.log(req.query) //query object will have all the query strings
})
input: localhost/products/?search=games&rating=5
o/p: {search: "games", rating: 5}

we can access search value in route as req.query.search

Express do not validate whether we provided value in query strings, we can write simple if statement for that

app.get('/products', (req,res)=> {
    if(!req.query.search){ //checks whether we provided a value or not in query string
        return res.send({
            error: "You must provide location"  //we are using return statement to stop the execution because we    
                                                //cannot send two responses from a route. server is like one request and one response
        })                                         //we get an error as "cannot set headers after they are sent to client"
    }
    res.send({
        products: []
    })
    console.log(req.query) 
})

follow same procedure for /weather route

wire up geocode and forecast to /weather route
1.
const geocode = (address, callback) => {
    const url = "url/+address+" //we can send diff address as we are using dynamic address

    request({url:url, json:true}, (error, response)=> {
        if(error){
            callback('unable to connect to --service' , undefined)                                 
        } else if(respone.body.features.length === 0){
            callback('unable to search location', undefined)
        } else {
            callback(undefined, {
                latitude: respone.body.features[0].center[1]
                longitude: respone.body.features[0].center[2]
                location: respone.body.features[0].place_name
            })
        }
    })
}
2.
geocode('philly', (error, data)=> { 
        if(error) {
            ***return console.log('Error', error)
        } else {
            //console.log('Data' , data)
            const lat = data.lat
            const long = data.long

            forecast(lat,long,(error, forecastdata)=>{
                if(error){
                  return console.log('Error', error)
                }
                console.log(data.location) //location we get from data object when we execute geoCode
                console.log(forecastdata) //string text of forecast
            })
        }
})

Final JSON endpoint:
3.
app.get('/weather', (req,res)=> {
        if(req.query.address){
            return res.send({
                error: "you must provide location"
            })
        }
    geocode(req.query.address, (error, {latitude,longitude,location})=> {  //lat,long nd location are returned by callback function so instead of "data" object 
                                                            //we are destructuring and grabbing lat,long and location prop from data object
        if(error) {
            return res.send({ error })  //instead of console.log we are rendering json response with error which is destructured.
    
        }
          forecast(latitude,longitude,(error, forecastdata)=>{ //passing lat,long from geocode to forecast
                                                                //forecastdata has forecast string
                if(error){
                  return res.send({error})
                }
                res.send({ //if geocode and forecast goes well, we are sending final json
                    location ,
                    forecast: forecastdata,
                    address: req.query.address
                })
            })
        }
    })
})

sumry: 
1. geocode function takes the address and callback 
a. address is used to get the cordinates for that address/location. we concat it to url and pass it to request module
    requestmodule is used to perform http/https request to servers, we are doing https request to geocode server/service
    geocode returns the json response
b. callback is used because, we cannot send data from asynchronous function here it is request module so we are sending
    response which we get from mapbox api {geocode}. we are sending i) error ii) object with latitude, long and location
    as arguments to callback func.

approach is same for forecast.

2. we called geocode with a) location, b) callback - callback will have error and object (data). {{geocode expects those two}}

if callback func returns error then we print error or else we send lat,long and location to forecast.

forecast is also same it returns forecastdata{forecast string}

3. instead of console.log we are sending json response. {JSON endpoint - /weather returns location, address-what user typed and forecast}

simple terms - for request module pass url with address and it either gives error or response. pass it to callback func
display error or use response prop and pass it to another func(forecast)
forecast also do the same, pass response(data object - lat,long,location) from first func to request module
request module either returns error ot response
display error or response from forecast (address,location and forecast)

J11
default func parameters:

const greeter = (name) => {   //name - parameter
    console.log('Hello' + name)
}

greeter('srk') //Hello srk
greeter() //Hello undefined. so if user doesnt provide argument we get undefined (default value)

To solve the above issue we can use if statement but we also have a option to put default values to parameters.

const greeter = (name = 'srk') => {   //name - parameter
    console.log('Hello' + name)
}

greeter('bob') //Hello bob
greeter() //Hello srk because if picked the default value.

Issue with destructuring: what if we do not provide value to destructured prop?
we get undefined.

const product = {
    name: laptops,
    value: x dollars,
    available: true
}

we can destructure above object as const {name, value} = product
and in func
const availableProd = ({name, available}) => {
    console.log(name)
}

availableProd(product) //this works fine and we get name prop value - laptops
but what if we do not provide product as argument to func call? what will be the output for the destructured prop?
we will get an error as "Cannot destructure property "name" of undefined or null"

so we can fix it by adding empty obj to that destructured obj, we will get undefined value for the variable
but it solving cannot destructure error which did not allowed to enter into the func. it failed on func first line

const availableProd = ({name, available} = {}) => {
    console.log(name) //undefined
}
availableProd() // we will get undefined and by passing empty obj to destructured prop, we fixed cannot destructure error on line 1

const availableProd = ({name="srk", available} = {}) => {
    console.log(name) //srk
    console.log(available) //undefined 
}
availableProd() // we will get srk because we used default param's. 

**passing {} to destructured obj {lat,long,location} in our script. (all scripts where ever we destructured obj)
why are we destructuring with empty object?

because if we provide wrong location like address=!, our server gets crash this is because when we put wrong
location we get error not response. in our code we are destructuring response {lat,long,location} but here
the respone is undefined and when we do destructuring on undefined we get cannot destructure error {code terminates on destructured line}

to fix this we are passing empty obj {} to destructured obj. if we pass obj (response), destructuring can be done and if 
we dont pass obj, empty obj will be set, there by moving code to next line whether we send or do not send response.

app.get('/weather', (req,res)=> {
        if(req.query.address){
            return res.send({
                error: "you must provide location"
            })
        }
    geocode(req.query.address, (error, {latitude,longitude,location} = {})=> {  //if we do not send response, we get error and in next line we are printing/sending error 
                                                                                //{yes lat, long values will be undefined but our error code gets executed no so no worries}                
        if(error) {
            return res.send({ error })  
        }
          forecast(latitude,longitude,(error, forecastdata)=>
                if(error){
                  return res.send({error})
                }
                res.send({ 
                    location ,
                    forecast: forecastdata,
                    address: req.query.address

                })
            })
        }
    })
})

Now we have JSON endpoint (backend) which sends json. we need to wireup with frontend.{user can enter text in search form
and click on search button from UI, request should come to server and server should send response for that location and browser should render the forecast }
wireup frontend and backend.

Browser http request with fetch:
homepage - index.hbs view
we linked in app.js client side js to that view. for rest of the files we did not. index.hbs is the only
file that needs to fetch forecast, that we write it in client side js app.js file using fetch api

client side js runs in browser.
making http request from client side js we will use fetch api. Fetch is not part of JS, it is browser based api
can use in all modern browsers
not accessible in nodejs so we cannot write in backend scripts.

fetch('url').then(()=>{}) --> takes url as argument, it is similar as request api. request api takes second argument
as callback func where as fetch do not take second argument, it uses promises then method
so if we get data then method will be executed.

fetch('url') calls asynchronous IO operation like request api. we will not get data right away, we provide a func that runs
when the data is available.

url = we use json end point that we created. returns json with forecast, location etc else error

fetch('url').then((response)=>{ //if we get response, then "then" method will be executed, and has the access to response
    response.json().then((data)=>{ //on response we use .json() method to parse the response. (response will be in the form of json, the end point we created returns json)
                                //once the response is parsed, it will be accessible in then method.
                                //data is object , on that object we have error prop if it returns error else forecast and location.
                             //access those prop as data.error for error and data.location and data.forecast for valid response
               if(data.error) {
                   console.log(error) //this console displays on browser.

               } else{
                   console.log(data.location)
                   console.log(data.forecast)
               }           
                }) 
        })
url we are using - http://localhost:3000?address=boston.
we are hardcoding address value, we need user to type in address in browser
Create a search form: 
in index.hbs file create a form 
<form>
<input placeholder="Location">
<button>Search</button
</form>

select the form element in app.js file using querySelector. when you are linking app.js to index.hbs
put script tag under body tag, this ensures html loads first than js file.

const weatherForm = document.querySelector('form') //returns element store it in a variable and form in querySelector is a tag name.

we now need to write some code which executes when user interacts with that form by submitting location.
we use event listner on that element.

weatherForm.addEventListner('submit', (e)=>{ //submit is the event name. once that event is occured we can access that event in cb.
    e.preventDefault() //browser default behaviour is to refresh the page after submit. so we are stopping it using preventDefault method
})

we need to access the value that user enetered. same use querySelector to select that element
const search = document.querySelector('input') //input is the tag name which we need and where user enter the location

weatherForm.addEventListner('submit', (e)=>{ 
    e.preventDefault()
    const location = search.value  //search has input element and value of input element is accessed by .value
fetch('https://localhost:3000/weather?address='+ location).then((response)=>{     //use fetch api to get the forecast by passing user enetered location
    response.json().then((data)=>{ 
               if(data.error) {
                   console.log(error) //this console displays on browser.
               } else{
                   console.log(data.location)
                   console.log(data.forecast)
               }           
                }) 
        })
})
instead of console.log, we can create two paragraphs and render the forecast in UI.

below the form create two paragraphs, to identify uniquely put id attributes. 
querySelector('p'), querySelector matches the first element matched we need to identify uniquely
<p id="message-1"> </p> //error or location
<p id="message-2"> </p> //forecast
now we can target these paragraphs and render data

const messageOne = document.querySelector('#message-1") //if it is id use # and for className use dotClassname 
const messageTwo = document.querySelector('#message-2")

textContent is used to set the content. goal is when user click on submit we display 'loading' text, once
we get response we display location in para1 and forecast in para2.
so we Overwrite 'loading' text to location text. same with error

weatherForm.addEventListner('submit', (e)=>{ 
    e.preventDefault()
    const location = search.value 
    messageOne.textContent = 'loading...' //so addEventListner only executes when user click on submit
                                        //we are displaying 'loading' for para1 and there is no value set to para2 so it wont display

    fetch('https://localhost:3000/weather?address='+ location).then((response)=>{
        response.json().then((data)=>{ 
               if(data.error) {
                   messageOne.textContent = data.error // we are Overwriting loading text from para1 to error that we get as response
               } else{
                   messageOne.textContent = data.location //Overwriting loading to location response
                   messageTwo.textContent = data.forecast //putting para2 value as forecast response.
               }           
                }) 
        })
})

styling part : input and button, using element names for styling because all the input boxes and buttons will have same consistent styling

Application deployment::
till now our application is running locally in ur machine and we need a url where user can access in browser and search for forecast for any location of his choice.

git, github and heroku.
git: allows us to put our app under version control. allows us to track our changes over time.
github: allows to back up our source code and collabrate with others
heroku - deploy our app to production server. Everyone can access.

signup github - a development platform. allows us to manage our project. track changes over time. collabrate with team
track bugs/issues and feature requests. host public or private projects. most of the npm modules are hosted on github

signup - heroku - application deployment platform, gives us tools and 
infrastructure neccessary to take our nodejs application and deploy it into their prod servers.

install heroku command line tools - these gonna give us access to various commands we can use from the terminal to deploy
our latest code changes to prod servers allowing users to see changes in our app.

heroku cli - article devcenter heroku - install in ur machine based on ur OS.
after succesful installation, restart the terminal

type in console
heroku -v -- to get the heroku version.

heroku login
links the commands we run from the terminal to our heroku account {allows us to manage our project from vs code}

press any key , opens new tab in browser and login to heroku account in browser {close that tab}

in console it display - logged in as xxxxxxx
Git version control:

version control allows you manage the versions of your app over time.
add feature
save points 

changes > deploy > revert > rework > deploy 
without version control its hard to get the previous version/state.

if anything goes wrong, manually verify where and what went wrong. with vc we can track in which version the wrong happened

we are using git version control

install git 
git-scm.com website
installer for ur OS, download.

check the option git bash, if os is windows. while installing git using git installer

restart terminal

git --v
print version

put our proj in version control to track of its changes over the time. 
then take those changesto send off to github/heroku servers by running commands from the terminal.

version control with git
untracked files     unstaged changes    staged changes      commits

we have new nodejs proj
1. run a command to initialize git in that proj
2. files to proj
    untracked files - by default git doesnt track your files, you have to run commands telling git to track specific files
            all new files of your project are untracked files
                src/app.js
                readme.md - markdown file
    
    **** when something is committed to the git , git starts tracking that file. it is a two step process
            a) git add . -->  staged changes b) git commit ----> commits

3. use command git add filename or git add space dot (git add .) to add one or more files to staged changes
    src/app.js - is now in staged changes   {staged changes -- about to be commited}
4. Now commit the file using the command git commit -m "message"

now git creates a commit with id 1aed4...

5. add new file src/utils/geocode.js this will first under untracked files
6. modified app.js because of geocode.js file. As we committed app.js earlier, git is tracking this file.
    when you modify app.js, it comes under unstaged changes

7. Now use git commit command, geocode.js and app.js will be commited and git generated id 1sada44fsdf....

now we have two commits, we can revert back to previous versions if needed 

integrating git:




commands:
git init   ///in root proj folder
initialized empty Git respository in /users/srk/proj-path///.git

.git - created by git. git stores commits in datastructures inside .git.
respository - place where things related to git are stored. currently we have local respository.
when you integrate with github/heroku we will have remote respositories

.gitignore file ---> node_modules, ignores folders/files mentioned in this file

git add src/  --> adds src folder to staging area
or 
git add .  --> adds everything to staged area

git commit -m "init commit" --> -m message ""

SSH keys:



















