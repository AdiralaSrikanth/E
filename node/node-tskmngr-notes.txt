Databases and mongodb

connect to database
user authentication
data storage in db of user
file uploads for user profile pic 
email notifications
CRUD
Database - we are using mongodb to store user data.
J14
mongodb.com --- open source and available for all operating systems

No sql - not only structured query language

mongodb provides npm module that can be used to read and write to database

sql vs nosql
database > table(s) > individual items - row or record > column
database > collection(s) > document(s) - looks like json  > fields
A collection is a list of entries those entries are reffered as documents and documents have many fields.

installing mongodb
start up mongodb server and connect with node js

download server - community - based on OS
for linux - version - 4.0.X OS - ubuntu, pkg T0Z - download

Navigate to download folder - extract files > bin dir - contains executables to perform various tasks
main one is > mongod executable- used to startup the mongodb server

move this folder to user directory (permanent location)

Now, create a place for our data to get store. by default mongodb expects you to create a data directory at the root of your harddrive
in that place it expects db directory. will have permissions issue so create a folder in user directory
create folder "mongodb-data" in user directory which has mongodb {executables}

Terminal:
cd ~  --Navigates to user directory
pwd - print working directory
return path /users/aaaa
to start mongodb server - 
<path to mongod executable> --dbpath=<path to data folder>
/users/aaa/mongodb/bin/mongod --dbpath=/users/aaa/mongodb-data

initialize database and gets the db up and running. 
now go to mongodb-data and observe data is generated. 

installing database GUI viewer: robo3t (earlier robomongo) - mongodb admin tool - open source
download and install mongo 3t

opens mongodb connections panel > create connection > name-local mongodb > address - localhost and port - 27017

open shell > db.version() - method on db object - it is js

connecting to mongodb database from nodejs and inserting document :
we use monogdb native driver - npm module > allows us to interact with our database using nodejs.

docs.mongodb.com > docs > drivers > drivers are libraries that allow you to interact 
with the mongodb database from wide range of programming language

c,java,node,php,python --> click on nodejs > see/find the native driver for the platform

release and API section - click on API --> returns to documentation

google - mongodb npm module -- official native driver released by mongodb.
1. leave the current terminal, database server needs to be up and running in order us to connect to it. do not shut it down.
2. Open up new terminal

create a proj and open in vsc
npm init -y --> pkg.json
npm install mongodb@3.1.0
Now we can use driver and connect to our database and insert some data

file > mongodb.js
learning CRUD operations

const mongodb = require('mongodb') //returns object
to initialize connection
const MongoClient = mongodb.MongoClient
MongoClient give us access to the function neccessary to connect to our db so we can perform CRUD operations

we need to define connection url and db we are trying to connect to.

const connectionUrl = 'mongodb://127.0.0.1:27017' ---->connect to localhost url which is up and running. 
mongodb:// --> following their protocol, 
instead of localhost we are using ip address sometimes localhost has strange issues 

const databaseName = 'task-manager'
connect to our database/server
 
MongoClient.connect() -- connect method, takes 3 arguments 1. connectionurl 2. options object {useNewUrlParser : true -->parses url}
3. callback function- takes two arguments error and client, if we fail to connect to db, gives error and if we succeed, gets client

Connecting to a database is asynchronous operation. takes time for connection. callback will run when the connection is complete

MongoClient.connect(connectionurl, {useNewUrlParser : true -->parses url}, (error, client)=>{
        if(error) {
            return console.log('Unable to connect to database')
        }
        console.log('connected successfully')
    })
in other terminal where mongodb server running, we can see the connections with ip and port

in second terminal where we are running node app, it is still hanging and hasnt brought to normal command.

once the connection is opened, node process is up and running as long as connection active. can shut down.

insert doc:

MongoClient.connect(connectionurl, {useNewUrlParser : true -->parses url}, (error, client)=>{
        if(error) {
            return console.log('Unable to connect to database')
        }
       const db =  client.db('databaseName') //we store database name in databaseName variable, you dont have to mention, mongodb will create db if you dont mention
                        //db method takes database name and return database reference. can be used to manipulate data

//collection is a function and expects name of the collection
        db.collection('users').insertOne({
            name: 'srk',
            age: 26
        })
    //call a method on collection reference - insertOne() expects object as argument
    //inserting a document into users collection.
     })
save the file and run node mongodb.js
open robo3t --> right click the connection and refresh the shell > 
newly created database will be visible > collections
> users {we created} >right click collection > view documents

_id     //stores unique identifier for that particular doc. mongodb generates it //similiar to sql which generates increment id.
name
age
when you insert a document, it will have unique id automatically generated for us.

insertOne is asynchronous. we did not use callback above. it is not neccessary now but with prod app it is neccessary
if we want to handle errors or want to know that our operation performed as expected

 db.collection('users').insertOne({
            name: 'srk',
            age: 26
        }, (error, result)=> {   //second argument to insertOne, a callback which gets called when the operation is complete
                                //error or result - if things went well //result has operation result -which has data as well as the unique id  
            if(error) {
                return console.log('Unable to insert user')
            }
            console.log(result.ops) //on result we use one property called 'ops' - contains all of the documents (array of documents) that were inserted
        })
     })
save the file and run node mongodb.js command in terminal
returns inserted doc.

how will I know about 'ops' on result?? go to nodejs driver doc  > MongoClient > on MongoClient we have a method - connect > doc on that connect method

check the same for insertOne. collection>methods>insertOne>documentation.
insertOne - inserts one doc.
insertMany - inserts many doc

db.collection('users').insertMany([{
            name: 'srk',
            age: 26
        }, {
            name:'bob',
            age: 26
        }
        ], (error, result)=>{
            if(error){return console.log('unable to insert docs')}
            console.log(result.ops)
        })
     })
save the file and run node mongodb.js command in terminal
open robo3t and verify the inserted docs. 
J15
The objectID:
automatically created by mongodb and stores unique identifier for each document you insert into database.

GU ids - globally unique identifier. ability to scale up in a distributed system. 
multiple database servers running instead of one, allowing us to handle heavy traffic, multiple queries coming in
there is no chance of ids collision across all database servers. with increment id approach of sql, there may be a chance
of ids collision. a user will have a increment id (id=2)in one database server
and the other user will have same increment id (id=2) in other database server - id conflict

we can generate ids for our document before inserting them to our database.
instead of mongodb server generating ids, we can use mongodb library to generate our own objectID.

const {MongoClient, ObjectID} = require('mongodb') //returns obj and we need the prop of that object hence destructured.

const id = new ObjectID() //constructor function thats y new keyword and takes no arguments. generates id 
console.log(id) //5c1110c5c6cdac04f740575b - count 24
lets talk about id value. 5c1110c5c6cdac04f740575b
google - mongodb ObjectID > reference doc not api doc.

The 12byte ObjectID value consists of, 
1. a <4byte timestamp> representing the seconds since the unix epoach (point of units - midnight jan 1970)
2. <5 byte random no.>
3. <3byte counter. starting with a random value.>
combination of all these generates robust id. no need of server telling increment the id

open ObjectID node js doc. see the available methods
we use getTimeStamp() method - which returns generation date. returns the generation date(accurate upto the second) that this id was generated.

const id = new ObjectID()
console.log(id) //id that we generated.
console.log(id.getTimeStamp()) //prints the timestamp

db.collection('users').insertMany([{
            _id: id,     //for _id value we are using the id we generated. check the id of this doc and the id we generated -will be same
            name: 'srk',
            age: 26
        }, {
            name:'bob',
            age: 26
        }
        ], (error, result)=>{
            if(error){return console.log('unable to insert docs')}
            console.log(result.ops)
        })
     })
Above example is of - we can provide our own ids to the documents if we want to. we dont use it as it is extra work, mongodb will automatically generates it

How object ids are stored: 
ObjectID("5c1110c5c6cdac04f740575b") -- function call and a string is provided as a argument.
The above statement is for visualization purpose to see what's the id value. ids are binary data.
by storing binary data instead of string cuts half of the memory (size)

const id = new ObjectID()
console.log(id.id.length) //id has a prop of id - contains raw binary data
<buffer 5c 11 ... >
and can see the length - 12 (same as 12bytes we saw in documentation)
console.log(id.toHexString().length) //string representation, gives the length of 24 (double of original value)
ObjectID("5c1110c5c6cdac04f740575b")
so for visualization they put string and is a argument to a ObjectID function call, it then converts to binary data n store 
abstracts all from user.

Querying documents:
Read documents from database
1. find({}) -- fetch multiple documents out of the database. doesnt takes callback, returns cursor.
2. findOne({},cb)

db.collection('users').findOne({name: 'bob}, (error, user)=> {
    if(error) {return console.log('Unable to fetch user')}
    console.log(user) //if user found, returns user document object
})

//findOne accepts two arguments 1.obj 2. function
1.obj - specifiy search criteria ex: name
2. callback gets called when the operation is complete. either we get error or the document

db.collection('users').findOne({name: 'bob, age:1 }, (error, user)=> {
    if(error) {return console.log('Unable to fetch user')}
    console.log(user) 
})
There is no user with age 1, it did not throw error, output is null.
searching for a document and not finding it is not a error.

**if there are two users with name bob, findOne return the first match document. 
use ObjectID to uniquely identify that doc

db.collection('users').findOne({_id: new ObjectID("objectid..") }, (error, user)=> {})
will learn to avoid new keyword, it is standard way of doing when using mongodb native driver.

2. find({}) - doesnt makes sense if we use objectID as its gonna return one doc. find is used to return multiple documents

db.collection('users').find({age: 27}) it doesot take cb as second argument. return value is a cursor
cursor is a pointer to that data in the database. 
mongodb assume, everytime you use find, you always want to get back an array of all those documents.
other things you might want to do - get the first five documents (limit) or get the count (count) of matching documents. just the count not the documents

nodejs mongodb driver api documentation > cursor

find >return cursor > cursor has methods> limit or count or toArray methods etc
1.
db.collection('users').find({age: 27}).toArray((error, users)=>{ //toArray takes cb, either error or documents here users
    console.log(users) //lists users(documents) with age as 27 as a array
})
2. db.collection('users').find({age: 27}).count((error, count)=>{ 
    console.log(count) //returns count - simple integer count as 3 not the entire matching documents sending through wire 
})
Cursor advantage: sometimes I want to get the data (Ex:1) and sometimes I just want to get the matching documents count (ex:2)

***** Call backs explanation:
We need them because a lot of operations in JavaScript are asynchronous, or put a bit more simply they don't actually stop
the program from continuing until they are done like you are probably used to. But instead just run in the background 
while the rest of the code continues executing.

If you wanted to fetch some data from a server for instance (which could takes an unknown amount of time) 
it would be incredibly inefficient for your program to just freeze completely while it waited for that data to be fetched. 
So instead of doing that it's common to just run the fetching task in the background.

This means that if you have two functions in a row with function A being asynchronous then function B will be executed 
while function A is still running. In that case if function B depends on data that function A is fetching you will 
run into problems.

This problem is solved with callbacks. With a callback you can guarantee that function B is only called after 
function A is finished with its thing because function A is actually the one responsible for calling function B.

Asynchronous functions also aren't the only use of callbacks, but they are the most common and useful use of them 
that I can think of at the top of my head.
---------------------------------------------------------------------------------------------------

Promises:
make it easy to manage asyn code 
solve callbck problems
build on cb pattern. enhancement for cb's.

callback func:
---------------
const doWorkCallBack = (callback) =>{ //callback parameter
         setTimeout(()=>{                                           //simulating asyn process
              callback('This is my error', undefined)               //asyn task is complete (post 2secs) we need to signal the caller that we either got error or result
         },2000)                                                    //call back runs after 2secs                           
}

doWorkCallBack((error, result)=>{   //call back runs when I have either error or result.
       if(error) {return console.log(error)}                             //write logic here
    console.log(result)
})
whole point of using callback pattern is a way to allow the caller of doworkcallback to get the results
callback(undefined, result) - for result
callback('This is my error', undefined)-for error :::: o/p: This is my error.

Promises func:
--------------
to create a promise we use new keyword with Promise constructor function. takes 1 argument - callback func. -->takes two arguments resolve and reject functions as arguments
As nodejs developers, we are not going to create promises, typically they are created by the libraries we use
const doWorkPromise = new Promise((resolve, reject)=>{
        setTimeout(()=>{
            resolve([1,2,3])  //after 2secs we are ready to signify that we completed the asynchronous process
                                        //instead of using cb's we can use resolve - if we get the results that we expect or reject methods -error
                                        //callback('This is my error', undefined) - order is imp in cb whereas in promises func names signifies the success and error
            //reject('this is error')
        },2000)
})

promise is a obj and has methods like then and catch. doWorkPromise return a promise

doWorkPromise.then((result)=>{    //when everything goes well, it comes under .then block and has result as argument.
    console.log(result)     //[1,2,3]
}).catch((error)=>{            //query the db - network connection drops -cannot access db server then you can call reject, it comes to .catch
    console.log(error)
})

advantages:
clear semantics, easier to understand the intension of the code. resolve-reject
cb's - we have to find all callbacks nd we need to figure out which are the arguments that are provided - error prone.
we have one cb func nd we need to idenify error or result using if, whereas in promises you haveaccess to 2 func. resolve nd reject

in promises, we cannot call both resolve nd reject or two resolve/reject. once we call resolve/reject, then promise isdone.
we cannot change the state. failure to success
in cb's - we can use multiple callbacks pass/fail - no preventive measures can easily mess up.

                        fulfilled (resolved)
                     /
promise ------>pending   
        {asyn task}   \
                     rejected (reject)

Updating documents: updateOne, updateMany
update is depreciated.

if you do not use callback, updateOne returns promise
const updateprof = db.collection('users').updateOne({      //filter, update and callback or can use promise
    _id: new ObjectID("object id")      //targeting doc with id.
    },{
    $set: {                 //$set command is used to update the field , not part of api doc,{search google - update operators mongodb - reference doc}
        name: 'mich'        //updating name field. age field remains same.
          }
    })
updateprof.then((result)=>{  //we can remove updateprof variable and chain .then together - this runs for success case.
        console.log(result) //result have lot of stuff, useful - modified count - updateone so 1 or 0.
    }).catch((error)=>{
        console.log(error)
    })

$inc -- increment by
Sinc: {
    age:1   //increment age by 1.
    } 
//check robo3t for updates of documents.

Delete documents: deleteOne and deleteMany
deleteOne(filter,options,callback) return (promise)

const updateprof = db.collection('users').deleteMany({
        age: 27
}).then((result)).catch()

result -- deletedCount:2

Restapi and mongoose
express based rest api.
allow user to perform operations such as
signup
add task
fetch all tasks

mongoose -popular library when working with node & mongodb - easy system for modelling our data - for modelling things like a user or task
fields and datatypes and data validation.

setting up mongoose:
npm module mongoose - mongoose directly related to mongodb
allows us to do some of the things that we do not know how to do so far.
we know how to do CRUD operations, but what about the things
1. how do I set up validation for my documents defining which fields are required and which are optional
2. what types of data to expect for the fields ex: completed:true, it should be boolean not a string or number.
3. If user1 creates a task and I dont want user 32 to view that task - add authentication 
4. also allows us to do basic crud operations on mongodb database.

mongoosejs.com ->
ex given in that website. mongoose performing tasks
1. connect to db
2. create cat model
3. create new instance of cat model new Cat()
4. save to db.

2. model:
allows us to model something in real world that we gonna able to store it in database
ex: user /cat/furnitures /task
create models for collections that we want and use model to describe the data.{fields}

ODM - object doc mapper - map ur obj in ur code over to doc inside mongdb db.

npm i mongoose@3.1.16

folder strucure: appname>src folder- app source code will live>db folder > mongoose.js file
const mongoose = require('mongoose')
mongoose.connect() // we use it to connect to database. 
takes two arguments 1.connectionurl ---> <mongodb://ip&port<databaseName>>, 2. options object

mongoose uses mongodb behind the scenes
connect to db:
mongoose.connect('mongodb://127.0.0.1:27017/task-manager-api', {
    useNewUrlParser: true,
    useCreateIndex: true      //when mongoose work with mongodb, indexe's are created allowing qucikly access the data.
})

defining the model:
const User = mongoose.model('User', {       //accepts two arguments 1. model string name 2. definiton where we define the fields that we want
                        //set up all the fields as prop's on this obj.
    name: {             //field and whose value is a object
        type: String   //type of the field to accept string/number.
    },
    age: {
        type: Number
    }   
})
               
creating instance of the model to add documents to the database

const me = new User({   //use new keyword and constructor func for that model.
    name: 'srk',        //data, should match with the type we defined.
    age:26
})
not saving to database yet, we need to use methods available on the instance (here me)

in order to save model instance
me.save().then((me)=>{            //save method does not take arguments, it saves data in db. it returns promise
        c.l(me)                    //wait for saving process to finish, then it either resolve or reject.
                                //when things go well, we get access to our instance model
}).catch((error)=>{
    c.l(error)
})    
.then or .catch -> register a handler when the promise is fulfilled/rejected

***Data validation and sanitization:

Data validation: data confronts to some rules 
ex: user age >=18
Sanitization: Alter the data before saving it
ex: removing empty spaces around user name - trim.

mongoosejs.com docs
validation
1. setup some of our fields required {required: true}

inside model:
name: {
    type: String,
    required: true //you have to provide name field while creating a user. field without required are optional we can add to db without them
}
mongoose documentation
Builtin validator : there are less validators
1. All schematypes have the built in validator. 
2. Numbers have min and max validator. String have enum,match, minlength and maxlength.
To validate valid email or social cvv number or validate user age >10 etc, mongoose does not provide many validators

mongoose allows us to setup custom validation , allowing to validate anything
we can customize our own validator, using validate function,

age: {
    type: Number,
    required: true
    validate(value) {    //es6 func. takes one argument on that field. based on type "value" will be there number/string etc.
        if(value<0) { //ppl should not enter negative age if yes throw error
            throw new Error('User age should be positive') //using js Error method to return error
        }
    }
}
we can also use Validator npm library to verify more complex things like valid email, social cvv number etc. instead of
we spending time on writing validation code we can use libraries to save time n effort.

npm validator
npm i validator@10.9.0
load library in our app.
const validator = require('validator)

email: {
    type: String,
    required: true
    validate(value) {    //es6 func. takes one argument on that field. 
        if(!validator.isEmail(value)) { //validator module has isEmail() func takes in string and returns true or false
                                    //if you provide wrong email it returns false and we flip it to true to print error
            throw new Error('Please enter valid email') //using js Error method to return error
        }
    }
}
error obj -if something is wrong. comes under .catch() of save() promise. our error we will under message.

mongoose has other validators under schematypes {string,number,date,boolean,array etc}
list of options available for each schematype:
default  --can set default value - age:0 or name: anonymous
trim
lowercase
email: {
    type: String,
    required: true
    trim: true  //trims extra spaces.
    lowercase: true //coverts to LowerCase
    validate(value) {    
        if(!validator.isEmail(value)) {
            throw new Error('Please enter valid email')
        }
    }
}
**Using all above prop's, will have more control over the data that we are allowing to database

Structuring a Rest api:
Till now we defined models and we know how to create instances using those models and storing data in database

{http endpoints for tasks app:}

Restful api:
api - gives set of tools to build software app.

node provides apis like fs
express provides apis - provides set of tools that allow us to build soft app. like app, req,res

restapi we are creating also provides tools that allows others to build software.

REST - allows clients/webapps to access and manipulate resources using set of predefined operations
resource - user or task. 
predefined operations - create a new task or mark a task as complete
upload prof pic.

These predefined operations allow the client/webapps to go through the process of creating a front end for task manager

Representational - with a rest api we are getting and working with representation of our data. 
data is stored in database but using restapi
I can fetch data and manipulate data - CRUD operation
we are working with represention of our users and tasks

state transfer: a rest api, the server is stateless the state has been transfered from server to client
each request from client such as a req from a webapp app contains everything needed for the server to process that request
includes the operation they are trying to perform {GET}
all of the data the operation needs in order to work
authentication making sure that the user who is performing the operation is authenticated

requests are made via http requests
client/webapp able to perform predefined operation

client >>need task data to show >> make a http request to a specific url on the server >> GET /tasks/a7eee>>server> server finds the data in db
>>server>>send back as part of http response>>>200 status code - JSON response>>client render the data.

POST  req- status code 201 - resource created.

client>srk - authenticating>>request> POST /tasks - JSON request {sending along json with req ex:desc and completed status}>>>
server authenticate the user>>>create that task/todo associated with us>> sends response -- 201 hhtp status code - resource created>> 201-JSON response>>client >render data 

Predfined operations for our resources:
we need to expose our predefined operations ex: CRUD operations
                        create  POST /tasks      // every single rest api defined with two pieces of data 1.http method 2. path
TASK RESOURCE           read    GET /tasks          //path is same
                        read    GET /tasks/:id   //id is placeholder and is dynamic

                        update PATCH /tasks/:id
                        delete DELETE /tasks/:id

/tasks is a pluralized resource.

we gonna send 100s of http request b/w client and server. what we gonna send in request? we send text
Request:
POST /tasks HTTP/1.1     ---> request line --contains http method, the path and http protocol
Accept: application/json        //expecting json data back
Connection: keep alive           //3 request headers, allows you to attach meta data to req
Authorization: Bearer eysfsdfdsfdfsds      //setup authentication.

{description: "order new books"}    //request body. post data and provided as json.

Response:
Http/1.1 201 created        //status line protocol, status code, text represention of status code
Date: sun 28 jul 2019 15.30 
Server - Express                //response headers
content-type: application/json

{"_id": "5cdddd", "des..":"ordd..", "completed": "false"}  //response body.

installing postman - allowing us to verify our rest api working as expected without the UI/client.
getpostman.com. - download the app.
create request.
collection - store related requests

postman homepage -
httpmethod - GET/POST
url that we are trying to make request to.
GET url/weather?address=hyd {can add address in params sec as key value pair} /weather - endpint 
hit send button.

communicate with the server and gets response. body >pretty/raw
can see status code and time took and size of http response.

Resource creation endpoints:
endpoints involve resource creation

install nodemon as dev dependency -- npn i nodemon@v --save-dev --> to save nodemon as dev dependency
npm i express

scripts: {
    "start": "node src/index.js"
    "dev": "nodemon src/index.js"
}

create index.js file under src folder
const express = require('express')
const app = express() //create express app.
const port = process.env.PORT || 3000 //as we deploy to heroku so using port from env variable
const user = require('./')

app.post('/users', (req,res)=>{ 
    res.send('testing')
})

app.listen(port, ()=>{console.log('listening at port'+ port)})

postman>createcollection>request>users
post localhost:3000/users    send //gets the response

data from client to server -- json data via req body
body tab>raw>json

{
    "name":"srk",
    "email":"test@test.com"
    "password": "res123"
}
hit send , status code 200

in the route how can we access the data sent?
two step process
1. json is sent so we need to configure express app.use(express.json()) -->converts json to object {{parses incoming json}}
2. we can use obj in route and is accesible under req. req.body

now we can create a new user. --> mongoose connects to database and we need access to model in this file

refactor folders --> 
src>models>user.js>>> put all models into individual files under models folder. ex: user model in user.js file etc
check the modules and require them in files

module.exports = User
exporting User model

index.js file
require('./db/mongoose.js')//returns nothing we just need mongoosejs file gets called results in connecting to database server
const user = require('./models/user')

app.post('/users', (req,res)=>{ 
    const user = new User({ req.body})//constructor func. requires us to pass obj with all the attributes. we have all those in req.body
 
    user.save().then(()=>{  //save to db. .then handles success
        res.status(201).send(user)       //in the example, did not put user in then cb func. recheck
    }).catch((error)=>{
        res.status(400).send(error)     //we need to send status code as well, currently for error it is sending status code as 200, change it 400
    })                  

})
senddata to server via http req using predefined operation we are able to perform some manipulation on database

httpstatuses.com

J16
Resource reading endpoints:
list of multiple items 
one item.

app.get('/users', (req,res)=>{
          //fetch users from db using mongoose                   
})

//we use mongoose to fetch all the users from database.
mongoose provides series of methods similar as mongodb native driver.

mongoosejs>doc>queries> list of methods available directly on model
ex: Model.deleteMany()
Model.updateOne(), Model.findOne() etc

app.get('/users', (req,res)=>{
    User.find({}).then((result)=>{    //on user model we use find method which returns promise n find takes object -find({}), define search criteria inside. finds all
        res.status(200).send(result) //if we find users we send users as result and status code of 200
    }).catch((error)=>{res.status(500).send()}) //sending internal server error
})

postman>new req in collection > read users >
GET localhost:3000/users send //returns array of users

/:id dynamic - capture the value and access that in route handler 
to do that express gives us route parameters, parts of url that are used to capture dynamic value

app.get('/users/:id', ()=>{ get request with /users/something,
    //req.params -->contains all of the route parameters that we are provided. here obj with single prop i.e id and its dynamic value
    console.log(req.params)  //new req> read user> GET localhost:3000/users/6737737373 -->as we are not sending anything postman loading screen appear
           //o/p in vsc : {id: "6737737373"} --id we are sending as route parameter and can see the value provided
})

Now we know how to access the value passed as route parameter, now we will find that user in db and return that user if any

app.get('/users/:id', (req,res)=>{ 
    const _id = req.params.id
    User.findById(_id).then((user)=>{ //findOne or findById query method - findById() does not take obj {}, just takes id  --recheck this statement
        if(!user) {
            return res.status(404).send() //user not found. ////mongodb query - you man not find user but treats as success, it searched and returned nothing - null - success {we might not get the user}
        }
        res.send(user) //status will be 200, you will user object.
                     
    }).catch((e)=>{
        res.status(500).send()
    })
 })
const _id = req.params.id       //gets id value as a string
User.findById(_id)

when we are using mongodb native driver we used to write new ObjectID("objectID") ex: findOne({_id: new ObjectID("string objectid..")
 here we are not doing it, mongoose converts string ids (5cedfge..)to object ids

/users/:id ==== req.params.id
post /users json body {} === req.body ===> update in users model ==> const user = new User({req.body}) then user.save(){save to db}.then().catch

J17
Promise chaining
Till now every time we used promise we did only one asynchronous thing. ex: findById
what if we want to use one thing and then something else? ex: mark a task as complete and get the records of incompleted tasks
two asynchronous things. one needs to happen and then another.

lets see how we write without promise chaining

const add = (a, b)=> {  //parameters
    return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                resolve(a + b)          //when add func called, we are returning a promises after waiting for 2 seconds
            }, 2000)
    })
}

add(1, 2).then((sum)=>{
    console.log(sum)
    //what if I want to do add one more async task ex: I want to add one more value to returned sum value.
    add(sum, 3).then((sum2)=>{      //second async call. one promise nested inside another
        console.log(sum2)
    }).catch((e)=>{
        console.log(e)
    })
}).catch((e)=>{
    console.log(e)
})
Issue with above code
1. when we want to perform another asyn task we are calling add func which returns promise and adding .then and .catch
    basically "Nesting"  what if we have around 20 asyn calls then will be nested too long {complex}
2. we are duplicating the code, writing .catch for all promises

solution: we can do promises chaining this is achieved by returning a promise from first asyc task
    and on that promise we can do .then {as it is promise we will have resolve and reject } and for all promises we can write one .catch.

add(1, 2).then((sum)=>{ //.then executes when add(1,2) fulfills
    console.log(sum)
    return add(sum, 3)  //returning a promise
}).then((sum2)=>{           //.then executes when add(sum,3) fulfills.
        console.log(sum2)   
    })
}).catch((e)=>{            //.catch executes for reject - this is for two promises
    console.log(e)

will see the same ex with findAndUpdate and getting the count

mongoose promises and chaining syntax
require mongoose file to connect to db and require User model
ex that we are working - find a user by id and update age = 1 and find all the users with that age
mongoosejs.com>queries> Model.findByIdAndUpdate
we have updateOne and updateMany also  //do not return document
findOneAndUpdate and findByIdAndUpdate() //return document {promise}
grab the id of a user from robo 3t

User.findByIdAndUpdate('5c1ef..', {age: 1}).then((user)=>{        //return promise and here the document - updated or individual user that is going to update recheck.
    console.log(user)                                       //return original obj not the updated one - to get modified doc use new:true under options
    //check doc mongoosejs.com>api --Model.countDocuments() -- gives the doc count .//Model.count() - depreciated
    return User.countDocuments({age: 1})
}).then((count)=>{
    c.l(count)
}).catch((e)=>{
    c.l(e)
})

findByIdAndUpdate('',{}) takes two arguments  1. find by id -string simple string id no need of new ObjectID('5c20ee00')
mongoose does it for us 2. what are the updates - {age:1} updating age field value to 1. no need to use $set
 mongoose does it for us as it uses mongodb native driver behind the scenes
after updating the document returns promise

return promise from findByIdAndUpdate to do promise chaining.

deprecation warning: given by mongodb native driver
findByIdAndDelete - find doc with the specified id and deletes that doc.

async-await:
one more topic related to asynchronous programming.
async-await - makes it so easy to work with our asynchronous promise based code.
 writing code that looks more synchronous than asynchronous

asynn-await is merely small set of tools makes it easy to work with promises. still gonna using same old promise methods
 the only thing that gonna change is how we gonna manage our asynchronous code

will be using async-await in all our routes

const dowork = ()=>{
}
console.log(dowork()) //o/p undefined
we know that JS gonna return undefined when we do not return anything from a func which is called.

async key word , allows us to create async func in that func we are going to use await feature
mark a func as async func which is done by adding async keyword infront of the func declartion.
const dowork = async()=>{
}
console.log(dowork())
o/p: Promise {undefined}
when we call a async func it returns a promise and fulfilled with undefined as a value

async func always returns a promise. that promise is fulfilled with the value you as a developer choose to return from a func

const dowork = async()=>{
    return 'srk'            /asyn func always returns promise, here it is not just string as we are returning a string from our func 
                            //as it is asyn func then it returns promise which is fulfilled by value returned here string
}
console.log(dowork())
o/p: Promise {srk} 
when we call a async func which is returning a string, it returns a promise which is fulfilled with the string here 'srk' as a value

As dowork() is returning promise we can do .then and .catch instead of logging into console

const dowork = async()=>{
    throw new Error('Something went wrong')     //error-rejecting the promise with that error - .catch block
    return 'srk'            //returning a value, fulfilling the value of the promise.
}
dowork().then((result)=>{
    console.log(result)   //output - srk
}).catch((e)=>{
    console.log(e)
})
await operator feature:
how is it going to make our asynchronous tasks with ease 

Take our previous promise ex
const add = (a, b)=> {  
    return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                resolve(a + b)   
            }, 2000)
    })
}
with promise chaining
add(1,2).then((sum)=>{
    console.log(sum)
    return add(sum,2)
}).then((sum2)=>{
    c.l(sum2)
}).catch((e)=>{
    c.l(e)
})

with asyn await:
const add = (a, b)=> {  
    return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                resolve(a + b)   
            }, 2000)
    })
}
copy paste add func without changing single thing about it. this is done intentionally. when working with async await
you dont have to change how ur promise functions internally. all you do is change how you work with them
for us, mongoose does not need to write library in order us to use async await. mongoose supports Promises
so as a consumer of those promises we can use async await if we want to. 

const dowork = async ()=>{
    //await operator is used with a promise. await add(1,2) where do I get access to the data? if we are not using async-await
    //we use .then call and data can be accessed in that callback func {.then(()=>)}

     const sum =  await add(1,2) //add() looks like standard synchronous func. we can create a var to get access to the value that the promise is fulfilled.
                                //we have to wait 2secs. the adv is syntactical. we can return sum or call as many as add func calls - asynchronous
                                //fulfills promise and .then func will execute when we call dowork()
    //able to use code that looks like synchronous perform asynchronous task
     const sum1 = await add(sum, 2) //code is much simpler than promise changing. 
     const sum2 = await add(sum2, 2)
     return sum2                        //return promise after 6 seconds
    }

dowork().then((result)=>{       //promise fulfills so .then executes
    console.log(result)   
}).catch((e)=>{
    console.log(e)
})

advantage:
1. code is much simpler than promise chaining. not using many functions and return func values. leads some confusion situations
2. scope - when we use two .then - you cannot access first .then var in second so the scope is limited
we need to create one variable in parent scope and do all the stuff but in
asyn func everything come under one scope as defined in above ex: sum, sum1. sum2

Handling error
const add = (a, b)=> {  
    return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                if(a < 0 || b<0) {
                    return reject('values must be positive ')
                }
                resolve(a + b)   
            }, 2000)
    })
}
const dowork = async()=>{
     const sum =  await add(1,2) return promise
     const sum1 = await add(sum, 2)
     const sum2 = await add(sum2, -1)   //after 6 secs fails and goes to .catch block.
     return sum2                    
    }

dowork().then((result)=>{       //promise fulfills so .then executes
    console.log(result)   
}).catch((e)=>{
    console.log(e)
})

The await operator is used with promises in asynchronous functions. The await operator allows you to work with promises in a way
that looks like synchronous code. If the promise is fulfilled, the fulfilled value can be
accessed as the return value from the function.

It’s important to note that async and await are syntax enhancements for working with
promises. Promises are still at the core of asynchronous code that uses async and await.


User.findByIdAndUpdate('5c1ef..', {age: 1}).then((user)=>{
    console.log(user)
    return User.countDocuments({age: 1})
}).then((count)=>{
    c.l(count)
}).catch((e)=>{
    c.l(e)
})

 will work on above function using async-await

const updateUserAgeAndGetCount = async (id, age) => {
    const user = await User.findByIdAndUpdate(id, {age})          //destructured age . findByIdAndUpdate returns promise
    const usersCount = await User.countDocuments({age}) //awaits for the promise
    return usersCount
}

updateUserAgeAndGetCount('5c1ef..', {age: 1}).then((usersCount)=>{c.l(usersCount)}).catch((e)=>{c.l(e)})

Integrating async-await in routes:
index.js file

app.post('/users', (req,res)=>{ 
    const user = new User({ req.body})
    user.save().then(()=>{  
        res.status(201).send(user)   
    }).catch((error)=>{
        res.status(400).send(error) 
    })                  

})
making above route to use async-await

//when you add async it changes the behavior of the func. func goes from returing whatever value you return to always returning a promise
//goodnews is that express doesnot use the return value from the func . express doesnot care what we return 
//instead we use request and response to tell express what we want to do. in this case we added the async functionality
//without changing the behavior at all

app.post('/users', async (req,res)=>{ //take this func which we pass to express and mark it async func

    const user = new User({ req.body})  //we send json via request body from postman.
    
     //   await user.save()       //await the promise that is coming from .save(). At this point we have saved the user, 
                                //everything that comes after this line is only going to run once the user was saved. either success or unsuccessfully
        //next statement only runs if the promise above fulfills. if it is rejected rest of the function gets stop. everything next to it never ran.
//so we use try catch

        try {
            await user.save() //if this promise fullfills, goes to next step else goes to catch block
            res.status(201).send(user)
        } catch(e) {
            res.status(400).send(e)
        }
})
//eliminating .then calls
headover postman send good data {json body - required fields for user model} - 201 and bad data - 400

ex2:
app.get('/users', async (req,res)=>{
    try {
        const users = await User.find({})
        res.send(users)
    } catch (e) {
        res.status(500).send()
    }
})
ex3:
app.get('/users/:id', (req,res)=>{
    const _id = req.params.id
    try {
        const user = await User.find({_id})
        if(!user) {
            return res.status(404).send()
        }
        res.send(user)
    } catch (e) {
        res.status(500).send()
    }
})

Http endpoint for updating resources: express provides patch method
we use Patch http method and task is to update single user

app.patch('/users/:id', async (req,res)=>{

    const updates = Object.keys(req.body)
    const allowedUpdates = ["name","email","password","age"]

    const validOperation = updates.every((update)=>{
                return allowedUpdates.includes(update)
            })  

    if(!validOperation) {
        return res.status(400).send({"error":"Invalid updates!"})
    }
 
    try {
       const user = await User.findByIdAndUpdate(req.params.id, {req.body}, {new: true, runValidators: true})
        //findByIdAndUpdate mongoose method & $set is not req. mongoose handles it

       if(!user) {
          return res.status(404).send()
       }
       
       res.send(user)

    } catch (e) {
        res.status(400).send(e) //two things 1.network error - unable to connect to db - send 500
                                //2. validation issues ex: for name instead of string value user provided empty string. 
                                //so sending 500 is wrong for both cases. use 400
    }
})

1. we are accepting fields to update via req json body. so if user provide a field which does not exist in user model/document
express is sending 200 status nd ignores the field ex:height . to do defensive programming we are checking the fields which user want to update


    const updates = Object.keys(req.body)
    Object.keys(req.body) -- object.keys creates/returns a array of strings here keys provided by user in req json body

    const allowedUpdates = ["name","email","password","age"] //not providing _id

    const validOperation = updates.every((update)=>{
                return allowedUpdates.includes(update)
            }) 

    every is js array method. it returns true if all the array elements are true ex: if there are 10 elements , it returns true only
    if 10 elements/conditions are true else false

    we are checking the fields provided by user if that field doesnot exist we send 400 response
2. 
try {
       const user = await User.findByIdAndUpdate(req.params.id, {req.body}, {new: true, runValidators: true})

      1.  we are getting id from req params so req.params.id --sending via url in postman
      2. instead of hardcoding we are getting fields to update from user via req.body json
      3. third argument is options object - new:true is when findByIdAndUpdate operation performed
        by using new:true it sends the updated user with updated fields else it sends the user when it finds

        run validator - required fields, types- mongoose bypasses the mongodb and performs operations
        directly on the model/documents hence ignores our validators. runValidators enforces to check our validations

        next steps only run when the promise fulfills else goes to catch block
       if(!user) {
           res.status(404).send()
       }
       
       //if there is no user found by the query findByIdAndUpdate we send 404 

       res.send(user)

    } catch (e) {
        res.status(400).send()
    }

Delete:
app.get('/users/:id', (req,res)=>{

    try{
        const user = await User.findByIdAndDelete(req.params.id)
        if(!user) {
            return res.status(404).send()
        }
        res.send(user) //deleted user
    } catch (e) {
        res.status(500).send()
    }
})

separate route files:
refactor
currently index.js file has every single route tasks and users routes {break it in small files}. separate users and tasks routes

setting up multiple express routes will be combining together to create complete application

4steps process:

const router = new express.Router() //creating a new router
app.use(router) //registering with existing express app
router.get('/users', (req,res)=>{res.send('test')}) //setup the routes
module.exports = router //can be used in diff files.

create folder routers - user.js {user router}

const express = require('express')
const router = new express.Router()

router.get('/test',(req,res)=>{res.send('from other file')})
module.exports = router

index.js is the main file so import user router in index.js
const userRouter = require('/routers/user')

app.use(userRouter). register with our existing app
change all app.get to router.get()...

1big file>split to 3> index.js creates express app > what this express app does is defined in other files {router}

Authentication and security:
all of the api endpoints are publicly accessible. anyone can come along and do something - delete data etc
user need to sign up or login before they gonna do be able to do something. create a task or delete a task
by forcing user to login, we are creating a relationship b/w user and task. this makes sure user 1 cannot see user 32 task
J18
Passwords
currently we are storing passwords in plain text - security issue
we use bcrypt to hash the password.
hashed password - we cannot bring back to original value
encrypt algorithm - password - we can bring back original password

npm i bcryptjs
const bcrypt = require('bcryptjs')

const passwordHashing = async ()=> {
        const password = 'Black12345!'
        const hashedPassword = await bcrypt.hash(password, 8) //hash method of bycrypt takes two arguments & returns promise 1. password to hash
                                                            //two - no of rounds that algorithm should run to hash the password

    //We store hashedpassword in db but how this gonna work when user login next time by entering plane text as password in UI

    const isPasswordMatch = await bcrypt.compare('Black12345!', hashedPassword) //returns true if macthed else false
   
    behind the scenes bcrypt hash the first argument that we provide {plain text} and compares with second arguments
    which we fetch from db, both are hashedPasswords. compare returns true or false.

}


findByIdAndUpdate do not run validators. Thats why we switched it to .save() so it runs validators
we used options as runValidators: true

The findByIdAndUpdate bypasses the .pre('save') middleware because it's not a save operation, 
it's an update therefore if we try to update the password, it's not going to be hashed since our middleware 
isn't being triggered

*****************************************************:
const obj = { a: 3, name: "srk" }
 
console.log(obj.a) // outputs 3
 
console.log(obj["a"]) // outputs 3
console.log(obj["name"]) // outputs "srk"

For example, this:

user["email"] = req.body["email"]
Means "Assign the value of the email property in req.body to the email property of user". 
You when you use obj[key] you're accessing the value of the key in that object. 
When you use the assignment operator on obj[key] you're assigning a value to the key.
*****************************************************:

const user = await User.findByIdAndUpdate(req.params.id, {req.body}, {new: true, runValidators: true})

findByIdAndUpdate bypass mongoose so we have to tell express to runValidators.

in current example .save is not called so .pre('save') middleware do not execute so we have to change above code
code to make use of .save to run middleware.

Securly storing passwords:
we are storing plain passwords in 2 places 1. registering /users and 2. update users /users/:id

customize user model. mongoose supports middleware, allows us to customize the behavior of your mongoose model.

mongoosejs.com>guide>middleware
middleware - register some functions to run before or after given events occur
ex: validate - I can run some code before or after a user is validated/ a user is saved {events - validate, save, remove}

run some code just before a user is saved. some code here is we check if the password is plain text if yes then hash it
restruturing user model:

we created a user model const User = mongoose.model('User', {
    name: {
        type:String
        trim: true
    }
})
second argument, we passed a object to the model. behind the scenes mongoose converts it to schema.
Now, we have to create a schema to take advantage of middleware functionality.
************************************************************
A Schema is an object that defines the structure of any documents that will be stored in your MongoDB collection; 
it enables you to define types and validators for all of your data items.

A Connection is a fairly standard wrapper around a database connection.

A Model is an object that gives you easy access to a named collection, allowing you to query the collection 
and use the Schema to validate any documents you save to that collection. It is created by combining a Schema, 
a Connection, and a collection name.

Finally, a Document is an instantiation of a Model that is tied to a specific document in your collection.
**************************************************************

const userSchema = new mongoose.Schema({    //obj - defines all of the prop for that schema.
    name: {
        type: String,
        trim: true
    }
})

last lines:
const User = mongoose.model('User', userSchema)
module.exports = User
middle line:
to set the middleware, use a method on userSchema

we have access to two methods on userSchema. pre - before save or before validate and post - events

userSchema.pre('save', async function (next) => {     //pre('event', func). use normal func - arrow functions do not bind this

    //we have access to this - here this is document which is getting saved
    const user = this       //ind user

    //how does it know that this func is done, 

    //here we hash the password - code


    next()  //pass to next middleware/func

})
when we send post req from postman to /users, middleware is working but for findByIdAndUpdate middleware is not working. 
bcz few mongoose queries bypass more advanced feature like middleware so we have to call .save to make use of our middleware

//findByIdAndUpdate method uupdates mongoose. it peroforms direct oepration on db that y even set runValidators.
//we can do more mongoose traditional way to amek sure our middleware works correctly

const user = await User.findByIdAndUpdate(req.params.id, {req.body}, {new: true, runValidators: true})

change the above code to
const user = await User.findById(req.params.id)

 now we have access to instance of user model
we can now update the prop's that are changed
 user.name = 'srk' 
 
 cannot hardcode, as the fields will be diff every single time.

 updates.forEach((update)=>{        //updates is a array of strings, here we are getting ind string in update
    user[update] = req.body[update]

    //we can access obj properties as obj["name"], here we do not know which fields are getting updated.
    //so we are looping through updates array and getting the prop and value from user[update] and setting the value
    //provided by user req.body[update]

    //ex: if a user send json as {"name":"srk"} , first we get all these as string array using Object.key(req.body)
    //then loops through this array to get ind key, now we update this particular key in a user document, user[update]
    //and the value we get from req.body[update] 

 }) 
    //we now updated the value, now save it, as we wrote middleware pre('save), our middleware gonna executed

    await user.save()
now we can hash the password in middleware
Load in bcrypt in user model

userSchema.pre('save', async function (next) => {   
    const user = this

    if(user.isModified('password')) //mongoose give isModified method on a document. return true if provided key value of a doc is updated
                                    //isModified returns true for 1. new value {first time entered pwd} 2. updated password key value
                                    //we should touch if is already modified.
        user.password = await bcrypt.hash(user.password, 8) //user is a document and getting password key value. overwriting the plain text value

    next()
})

above middleware works for both /users and /users/:id with hashedPassword

Logging in users: ///login route - email,pwd>job of the route tat user exists with those cred
creating a new router> /users/login> when user login with email and pwd > route verify whether user exists with those credentials.

router.post('/users/login', asyn (req,res)=>{
    //two ways to structure 1. write all the code here or 2. write resuable method which finds and returns user and call here.

    //work with user model and setup resuable func for finding a user by credentials

    try{
        const user = await User.findByCredentials(req.body.email, req.body.password) 
        //we can use available options but creating our custom func findByCredentials
        //create findByCredentials in user model

        //we have to create a separate schema and pass it to model
        
        //userSchema.statics.method name
    }
  
})
//statics on model, methods on schema. 
in usermodel.js

//we have to create a separate schema and pass it to model
//userSchema.statics.method name
when you call User.findByCredentials comes to user model

userSchema.statics.findByCredentials = async (email, password) => { //this binding so using arrow func
        const user = await User.findOne({email})
        if(!user) {
            throw new Error('Unable to login')
        }
        //verify the password using compare func of bcrypt. we saved user pwd as hashedPassword

        const isMatch = await bcrypt.compare(password, user.password) 
        //password - user provided one, user.password = returned user from findOne and its pwd

    //if there is no match

        if(!isMatch) {
            throw new Error('unable to login')
        }
        return user
}
 now in user.js (routes)

router.post('/users/login', asyn (req,res)=>{

    try{
        const user = await User.findByCredentials(req.body.email, req.body.password)
        res.send(user)
    } catch (e) {
        res.status(400).send()
    }
})
in the user model, set email field as unique : true {index will be created} so no duplicate email id for the users who login in

JSON web tokens:
public routes - accessible to anyone - /users /users/login
private routes - authentication - correctly authenticate to use it. 
ex: delete task - you should authenticated before you perform create task/ delete.

login with my account > get back auth token > perform delete/edit/create operations

JWT - JSON web tokens

npm jsonwebtoken

npm i jsonwebtoken

const jwt = require('jsonwebtoken')

const myfunc = () => {
    //To create a jwt token we use .sign() method available on jwt
        const token =  jwt.sign({_id: 'abc123'}, 'thisissecretkey') //return value from sign is new token
        console.log(token)
        
        sign({payload}, '') -- {} obj -contains data that gonna embeded in ur token. 
       for us using jwt for authentication, we store unique identifier for the user who is going to authenticated
        //second argument is string , secretkey. sign the token making sure that is not tampered or altered anyway
        //jwt.sign(payload, secretOrPrivateKey, [options, callback])

       o/p - token == **one.two.three parts
      one = base64 encoded json string - header -contains info - what type of token - its jwt here and which algorithm is used to generate it
      two = payload or body - base64 encoded json string - contains data that we provided - here _id
      three = signature - used to verify the token

      *** jwt isnt to hide the data you provide (here _id), it publicly viewable to anyone who has the token
      jwt is to create a data and verifyable with secretkey/signature. they cannot change the data we provided
       as they do not know the signature and algo used.

      test the value of "two" part - eytestbsvslkvslvjsvsv in base64decode.org site =copy/paste -   payload or body
      =>o/p json obj with two values -{_id:"abc123", iat: 11566} -
      1. first value _id - we provided,
      2.second value- iat:15215454 - issued at {timestamp}
       which is part of embeded json

      //till now we created a token will now see verify the token
    verify: 
      const data = jwt.verify(token, "secretkey")
      console.log(data) --gets the data back similar to base64decode page - check below

      //takes two arguments 1. token that you want to verify and 2. secretkey/signature to use. provide same secretkey
      that we used to generate token.

    verify will return the payload for the token if things went well else throw error
    o.p : {_id: 'abc123', iat: 155220} get the data back

      //if you alter the secretkey you will get Invalid signature error

    Another feature: jwt token can expire after certain time
    at the time of creation of token we can pass options as 3rd argument.

        const token =  jwt.sign({_id: 'abc123'}, 'thisissecretkey', {expiresIn: '7 days'}) 
}

myfunc()

Generating jwt:
/signup-/users and /users/login --- send back jwt auth token

create a resuable func as we are using in two places

J19
in /users/login route
func on model -User, const user = await User.findByCredentials() , here we are working on user collection as whole
in this case, we are trying a generate a token for a very specific user, so we define a method on user instance
const token = await user.generateAuthToken()

how we a create method on instance of user 
user model file
load in jwt
statics - model - model methods
nethods - instances - instance methods
userSchema.methods.generateAuthToken = async function() {
    //we are calling this func on specific user so we can have access to that specific user.
    const user = this

    const token = jwt.sign({_id: user.id.toString()},'thisissecretkey')
    //user.id gives you obj so convert it to string as jwt expects string
    return token
}

returning token from generateAuthToken, in login route store it in token var as it is a promise and return token & user
in user route file.

router.post('/users/login', async (req,res)=>{

    try{
        const user = await User.findByCredentials(req.body.email, req.body.password)
        const token = await user.generateAuthToken()
        res.send({
            user,
            token
        })
    } catch (e) {
        res.status(400).send()
    }
})
>>as of now, we are sending user and token to client. client can take this and make another request that require authentication
currently no req is requires authentication

in postman> login request> observe returning token
//everything is a string key value pair -json- retrieved from db

we are returning only one token, user may login from pc,laptop or mobile, we need to track them.
we did not save token in db yet

current setup: 
token>user can logout>but as long as token exists its like user is still logged in>
 wrong hands> for now we do not have option user to logout or invalidate that token

Tracking tokens : pc,laptop,mobile> from one system user can logout but from other systems user still active

update schema with tokens value
const userSchema = new mongoose.Schema({
    name:{
    },
    tokens: [{  //we want to store array of tokens so creating a array object.
        token: {        //defining how each doc in tokens array should look like - type & required
            type: String        
            required: true  //other validations like trim is not req. as server is generating it not the user.
        }
    }]
})
so in the generateAuthToken func, we can add newly generated token to the tokens array and save user. 
show token with the user

userSchema.methods.generateAuthToken = async function() {
    const user = this
    const token = jwt.sign({_id: user.id.toString()},'thisissecretkey') returns token value
    //used.id is obj and jwt accepts string to converting id to string
    //concat token to the array

    user.tokens = user.tokens.concat({token: token})
    //concat takes obj as we defined tokens array of object. prop is token and the value is newly generated token.
    await user.save() //saves token to db.

    return token
}


postman: {user}plus tokens[{}]
tokens has ind {} and each ind obj has _id.

//implement same func for signup.
sign up also gen auth token.

after user is saved to db in /users or /signup route, call user.generateAuthToken()>generates and save token> returns token

Express middleware:
now that ur api sends token for user signup or login. how those tokens are used to authenticate other requests.

except signup and login, every single request to the api is going to require authentication.
client needs to provide authentication token > server should validate before performing any operations deleteor update

without middleware : new request --> run matched route handler
with middleware:  new request ---> so something --> run route handler

with middleware we can customize our server to fit our needs.
do something is a func that executes as we like ex: check valid authenticate token

registering our middleware

app.use() // we used to provide something that is created by express. we never explicitly provided our own function
define the following code above all of app.use()

app.use((req,res,next)=>{   //this func going to run in between request that is coming and the route handler, 
console.log(req.method, req.path)                     //this func has same info accessed by route
//returns http method used and path used. GET /users
next()
//call next to tell express that we are done with this middleware.

not always wewant to call next. ex: get http method - donot allow
if(req.method === 'GET'){
    res.send('Get requests are disabled')
}else{
    next()
}
})

app.use((req,res,next)=>{       //registering middleware
    res.status(503).send('Site is under maintenance')//not using next bcz we want to stop other exec. 
})
now, get/post method to any routes results in 503. this we achieved by registering one middleware.

accepting authentication tokens:
client has to provide authentication token to server

setting up express middleware function you can use to add authentication to any request in ur application.

func > check for incoming auth token> verify that it is valid jwt > find associated user.

middleware to be used throughout the app. better to create a separate file - organized

create folder> middleware> file of middleware >auth.js

const auth = async (req,res,next) {
    console.log("auth middleware")
    next() //to allow the associated route handler to run.
}
module.exports = auth

earlier we used app.use() to register a middleware, itis associated and used for all routes 
but we dont want to use this middleware for all routes
ex: login and signup are public. 

to use this middle ware for a specific or individual route, pass it as second argument to the route
user router file
load in middleware

router.get('/users', auth, async (req,res)=> {
    res.status(200).send('middleware working fine')
})

when someone make request to /users, it first goes to auth middleware and returns to the route handler 
only if the middleware uses next() call.

now work on auth function: what this func do to make sure the given user is authenticated.

client has to provide authentication token which they get from login or signup and providing it with the request
they are trying to perform

grab the auth token of a user > post man > we can send this token via request header {providing additional info to server} 
>for the route which we added auth middleware
> key value> key is Authorization and value is <<Bearer Auth token>>

server also send back response header.

GET localhost:3000/users under Headers key: Authorization & value Bearer Authtoken

const jwt = require('jsonwebtoken')
const User = require('./usermodelpath')

const auth = async (req,res,next) => {
    try {   //attempting to validate the user, if the user is not the valid user catch block will run
            //if they are not authenticated we are not calling the next() for next router handler to run. we send error

    1. how can we get the value of the header. 
   // const token = req.header('Authorization')//to access incoming headers we use req.header('name of the header /key')
        c.l(token) // we get header value : Bearer <token>
        we do not need Bearer text use string .replace method to remove it. replace('which one to replace', 'replace with')
        const token = req.header('Authorization').replace('Bearer ','')
        if there is no Authorization key it is gonna return undefined and catch block will execute.

    verify the token -jwt with the same secretkey we used when we generated
    
    2. make sure token is valid. ensure it was created by our server and is not expired

    const decoded = jwt.verify(token, 'thisissecretkey')
    //decoded is sjnfksjsdffj token value to the payload which we passed ex: _id
    //I think verify verifies the token secretkey with the secretkey we provided
    if the given token is valid ,if it valid, we can find the user in db, 
    we embeded the user id as part of token, grab that _id value {user}

   // const user = await User.findOne({_id: decoded._id})
    _id is stored on decoded. verify returns payload - the dat we provided - _id and now decoded var has it

    The other thing we want to check is that this token {client provided} is still part of that tokens array. when a user logs out
    we are gonna delete that token so want to make sure that it exists inside array

    //To do this we need to pass another option to findOne, key and values are string
        tokens.token : token
        checking the provided token in tokens.token

    const user = await User.findOne({_id: decoded._id, 'tokens.token': token})
    this gonna look for a user that has given token value in one of the array items in tokens array    

****. find a user with the correct id who has auth token is still stored. if provided token is not present in 
db/tokens array - usser will be null then > no user> throws error>catch block 401

if(!user){
    throw new Error() //triggers catch block
}
other thing we can do is pass that route handler, the user we already fetched from db. no need of route handler 
fetching it again from db

req.user = user //adding a prop to req to actually stored fetched user and router handler can be able to access the user
 next()

    }catch {
        res.status(401).send({error: "Please authenticate"})
    }
}

GET localhost:3000/user -- get users data as array that means authenticated correctly

change the token string post man - get error {error: please authenticate }

only when we provide valid token then only we are able to access given endpoint. locking down the data

router.get('/users', auth, async (req,res)=>{
    try{
        const users = await User.find({})
        res.send(users)
    } else {
        res.send(500).send()
    }
})
Above route uses auth and There is problem with above req. it exposes all the users data to evryone though authenticated
I should not see others emails who signedup

path is changed to /users/me
router.get('/users/me', auth, async (req,res)=>{
    res.send(req.user) //we get this req.user value from auth middleware. now the user is able to view only his profile      
})

jwt.verify(token, 'secretOrPrivateKey') //verifies the token with our secret key. true the returns payload here _id

Advanced postman:
currently we a have collection and it has request. in all of the requests we hard coded url as localhost:3000
but when we deploy to heroku we have to change the url in all requests

postman provides environment in those environment we can define environment variables
click on gear icon next to no environment> manage environments > add
add env name: taskmanagr api (dev)
variables: varialbe: url initial value - localhost:3000
to use this environment var

select the environment here taskmanagr api (dev) and in the request to use environment var use {{variablename}}
GET {{url}}/users === GET localhost:3000/users

2. Read profile is only request which has auth setup. providing auth token as req headers
If we want to use same token for other requests?
we have to add auth token to all the request instead of doing this

copy token
move to Authorization tab:
we can select the type as Bearer token and add value to it.

but it is alos accessible to this request, to access this token in all requests.
collection> edit> Authorization tab> select type as Bearer and add value

in all the requests set type as Inherit from parent > under Authorization tab.
we dont need Authorization in create user and login user so set no auth for those requests

Bearer tokens - strategy

Manual work - create a user / login a user - we are getting the token and updating in collection {parent}
we can avoid this by writing JS code under Tests tab

Pre-request script - JS code to run before the request
Test - after the response

task: extract the token prop on the body and set that as environment variable.

under collection Authorization remove the token and add a env var {{authtoken}}
this Authtoken we set the value from response body by writing some js code
Tests tab:

1. we want to make sure we get status code as 200 or 201
if(pm.response.code === 200) {    //pm - postman - its is a obj and response.code give response code
    //set env var
    //pm.environment.set()
        pm.environment has a method set to set the env variable. 
        set('env var name','value') - two values 
        pm.environment.set('authToken',pm.response.json().token)
        //pm.response give json use .json() to convert it to obj and access token from on that obj.
}
now we have script that sets authtoken automatically. if token expires we can run login req and token is set as env var.

change the status code === 201 in create user.

Logout: create a new router > logout.
till now we have login where we generate token and auth middleware to validate the token. after validation user can delete
or update the task
will figure out how these auth tokens are removed when user is done i.e logout

router.post('/users/logout', auth, async (req,res)=>{ //you have to be authenticated in order to logout.
        //we need particular token that they used when authenticating
        //if user login 5 pcs , we dont want to del all token just the pc where he/she clicks logout - del that token

    try {
        //we authenticated so we have user data.

        req.user ois the user. now we can change the tokens array by eliminating used token - use filter method
        req.user.tokens =  req.user.tokens.filter((token)=>{ //token is array of obj and token is ind obj which has token prop
                return token.token !== req.token {auth gives this token}

                //ind token which is obj and which has token prop and _id prop.
                //return true for the token we are looking at isnt the one used for auth

        ** basically, auth returns a token as req.token, we have to del this token from user.tokens array as user
        clicked on logout. for this we are looping over tokens array and applying filter method - if the auth provided 
        token and a token from tokens array are not equal we return true if they are equal we are not saving it

        req.user.tokens = updated /filtered token value where auth passed token we delete
        now save it to db

        await req.user.save() 
        res.send()
        })

    } catch () {
        res.status(500).send()
    }
}) 

make small change in auth func. currently returning/passing only user return req.token = token. other route handlers
will have access to that token

now logout of all route:

router.post('/users/logoutAll', auth, async (req,res)=>{ 
    try {
        req.user.tokens = [] //setting token vth empty array.
        await req.user.save() 
        res.send()
        })

    } catch () {
        res.status(500).send()
    }
}) 

//why post req? for logout

flow --- user signup/login/use login toke /logout.




































