D21/J14
With react we can build web apps - runs on browser, native mobile apps and desktop app

Why should I learn react?
Reasons:
1. React library itself -
Small learning curve we can up and running with fundamentals of react in short time.
The Core idea is - Components.
ex: login, application header. Multiple Components together end up a complete application 
Components based architecture forces you to break complex app into small peices 
which are easy to build, maintain, test & debug
React is fast. Renders and rerenders app very quickly. 
keep up to date with the latest changes in ur app data

Can build web and mobile apps

2. React Community
Active Community. You dont have to reinvent the wheel again. 
you will have react libraries like calendar picker, drag and drop data in ur app
Great resources - tutorials etc.
fb,uber,netflix,twitter uses react.

code.visualstudio.com download & install it. developed by microsoft.

nodejs.org -- download and install it. node -v --version of node
npm comes along with node

NPM - node pkg manager
helps installing various dependencies like yarn, react etc
npm and yarn are similar
npm -v --version of npm
npm install -g yarn - we are installing yarn globally
yarn --version

Indecision app:
Create a public folder - assets that we are going to serve up
1. create html file under public folder - index.html

install live-server   ----live reload
yarn global add liver-server 
global - adding globally
add - install
live-server - module name
live-server -v --> version

yarn globally install modules, it does not add location to the path when you try
to use in terminal we get errors
npm install -g live-server.

now serve up public directory ---- run it from correct folder(where public folder is present) 
live-server public

JSX - Javascript xml, templating syntax provided by react. makes easy to build
structure of our application. everything we return to the screen is written in jsx.

install react
***Load React library using CDN. later on we load in react,react dom,router & redux using webpack.
in the html file use script tag and in src = "load react library CDN"
under body tag, 
<script src="https://unpkg.com/react@version/umd/react.development.js"></script>
version 15 or 16
you can find it in unpkg.com {google}

1. react - CDN
react can be used in diff context - react-vr , react-native 
2. react-dom - react in browser //to use react in browser we use react-dom CDN
3. local js file under scripts folder under public

After writing react,react-dom in src attribute of script tag, start the server and check
react and react-dom variables in console. these are displaying only because we added them in script tag
they are global react and global ReactDOM

JSX - Javascript XML {Javascript syntax extension}, provided by react.
define template, can inject/insert data into those templates.

scss,less - gives variable support and are lang extensions for css
similarly jsx is lang extension for react

D25
under app.js
var template = <p>This is JSX from app.js</p> //this is JSX

to render above template,
ReactDOM.render() //render method in ReactDOM is going to render our app.
render method takes two arguments
1. JSX, - template
2. dom element - where you want to render 

var template = <p>This is JSX from app.js</p>
var appRoot = document.getElementById('app') //defined a div tag and assigned id as app in index.html

ReactDOM.render(template, appRoot)

we will get the error as unexpected token <

chrome does not know what jsx is. jsx is not js, its a extension.
solution for above issue is take in JSX and convert it to Javascript
we use tool Babel to do this. (babel is a Javascript compiler.)
babeljs.io website

babel takes features from ES6 and ES7 code and compiles to ES5 code
Browsers like IE9 or 10 do not add latest features like arrow functions etc. 
using babel we can write arrow 
functions but at the end of the day it is es5 code in browser 

In babel site try it out page,
var template = <p>This is JSX from app.js</p>

compiles to old js functions which browser can understand. <p>JSX</p>, is converted to React.createElement() -- regular function call browser can understand
var template = React.createElement(
    'p',
    null,
    'This is JSX from app.js'
)

'p' - element 
null - these are attributes here it is null. when you add id="app" it will show as {id:"app"} instead of null. JSX attributes
last one is of content.

copy above React.createElement() code and put in vs code and comment the jsx line code and start the server. 
it renders content on browser

Installing and setting up babel locally:
this will allow you to write jsx in ur editor and automatically compiles to React.createElement method call
and renders in browser/able to view output instantly.

Babel is a compiler. Its not gonna compile by its own. we have to add plugins and presets in order to convert jsx to React.createElement
on try it out page of babel site, it already selected few presets - few checkboxes(es2015, react) selected.
preset - is a group of plugins

we need to include react-preset to convert jsx to React.createElement which browsers can understand

go to babel site > doc > plugins page.

1. click on react preset, it has plugins part of it. 
all these sub plugins are responsible for to convert jsx to React.CreateElement
2. preset -env which has es2015,16,17. now we can use latest js features- arrows functions, const, rest and spread operators etc

install 3 things
Babel
presets: react and env

yarn global add babel-cli@6.24.1

if you face any errors use npm install -g babel-cli@6.24.1

Gives access to command line interface to use babel compiler. but it does not come with es6,7.. js features or JSX support.

babel --help
lists all available commands if installed correctly

install react and env install locally in our proj, they wont give any commands like react or env instead we need their 
code to live in our project
babel cli use it to convert jsx to createElement calls

yarn init ---specify dependencies
hit enter

generates new file - package.json file - outline all of the dependencies

yarn add babel-preset-react@6.24.1 babel-preset-env@1.5.2 {chain up of dependencies}

after running the above command, there will be dependencies key value pair in package.json file and node_modules folder
under root of the project. all the dependency modules and sub modules are downloaded and placed under node_modules

yarn.lock file - lists out all the dependencies that used in node_modules with specific versions and from where we got that pkg

use babel
goal is to create one file and that file we change, then we gonna have another file get generated with compiled code 

folder
src/app.js  - we write all of the react code (JSX) in this file

folder that we created earlier
public/scripts/app.js --- auto generated compiled code will be generated here.(jsx to React.CreateElement call)
and index.html file gonna render this file

in terminal type in babel command

babel <path to our code which we want to compile> --out-file=<output file, overwrite this file for every babel run> <presets we want to use, comma seperated presets>

ex: babel src/app.js --out-file=public/scripts/app.js --presets=env,react
hit enter. no errors

go to public/scripts/app.js and observe compiled code i.e React.CreateElement call
Add --watch command, it watches scripts/app.js file and if there is a change in src/app.js file, 
it gonna generate compiled code again (bascically for every change)
babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch

make changes to src/app.js file and save, observe public/scripts/app.js gets change.

start live-server serving up public folder   -- live-server public ---> opens up server and serves up html in browser.
as of now src/app.js > changes >babel saw change> compiled new code in scripts/app.js > mapped in index.html > live-server saw change in scripts/app.js>
 >restarts server > renders index.html in browser.

can delete node_modules folder, can be reinstalled all the versions using yarn install, looks through pkg.json and installs all dependencies

add babel extension in vsc for syntax highlighting

lets add another tag to template
var template = <h1>Indecision app</h1><p>some paragraph</p>

when you save src/app.js babel recognize the changes and compiled code will be generated but here we get error

see the error in terminal

syntax error: src/app.js Adjacent JSX elements must be wrapped in an enclosing tag
with JSX we only have one root element
wrap h1 and p inside a div {wrapper div}

var template = <div><h1>Indecision app</h1><p>some paragraph</p></div>
valid jsx

for looking good - readability we can wrap jsx inside ()
var template = (
    <div>
        <h1>Indecision app</h1>
        <p>some paragraph</p>
        <ol>
            <li>Item One</li>
            <li>Second Item</li>
        </ol>
    </div>
    );

you can see how the above code gets compiled in scripts/app.js file. for each tag, React.CreateElement(..) will be created

Instead of rendering static data we can render dynamic data in jsx
{} - takes in js expression.
var userName = 'srk'
var age = 27
var templateOne = (
    <div>
        <h1>{userName}</h1> //we should use {} to use dynamic data in JSX, inside {}, it takes Javascript expression, here we are referencing userName variable
        
        <p>{userName.toUpperCase()}</p> //inside {}, we can use + to concat or string methods like toUpperCase() etc
        <ol>
            <li>Age : {age}</li> //combo of static text and dynamic var value
            <li>Second Item</li>
        </ol>
    </div>
    );
var appRoot = document.getElementById('app')    
ReactDOM.render(templateOne, appRoot)

Above we used string and number. now we will use object

var user = {
    name: "srk"
    age: 26
}

var template = (
    <div>
        <h1>{user.name}</h1> //u cannot directly put object as user,react does not understand, it crashes and do not render anything. we have to use obj.prop
        <p>{user}</p> //error in console - objects are not valid as a react child
        <ol>
            <li>Item One</li>
            <li>Second Item</li>
        </ol>
    </div>
    );
J24
Conditional rendering in JSX
if statements, ternary operators and logical & {and} operator.

we cannot put if statement in {}, it is the place for Javascript expression. we can define a separate function and call it in {}

var user = {
    name: 'andy',
    age: 26,
    location: 'philly'
}
function getLocation(location) {
    if(location){
        return location
    }else{
        return 'unknown'
    }
}
var templateTwo = (
    <div>
        <h1>{user.name}</h1>
        <p> Age: {user.age}</p>
        <p>location: {getLocation(user.location)}</p> //1. we can call function from Javascript expression in jsx 2.func used if statement.
    </div>
)

we can simplify the above templateTwo and getLocation function call.
1. function can return jsx expression
2. if the value from func call is undefined, then it wont render anything. 

function getLocation(location) {
    if(location){
        return <p>location: {user.location}</p>
    }
}
var templateTwo = (
    <div>
        <h1>{user.name}</h1>
        <p> Age: {user.age}</p>
        {getLocation(user.location)} //if it returns undefined then the element wont render in UI. if it returns true then that element will be visible.
    </div>
)
ternary operator:
will work on h1 tag, if there is username render name else display anonymous. we will use Ternary operator
 <h1> {user.name ? user.name.toUpperCase() : 'Anonymous'}</h1>

ternary operator is a expression we can use it inside {}. 
if true? execute this: else executethis
ex: true? 'name': 'anonymous'

boolean,null and undefined are ignored by JSX
Logical AND:

ex: if the user is less than 18, we dont display his age
true && 'someapps'
o/p - someapps

if the first one is true then statement two is executed or returned.
false && 'someapps'
o/p : false
first value false will be returned. if it false, it will be ignored by jsx

{(user.age && user.age >= 18) && <p>{user.age}</p>}
first will check for user.age if exists checks for age >=18 else renders nothing
if age is >=18 then rendres p tag- user.age, else do nothing

Conditional rendering smry:
1. ternary is great for - Condition if you want to do one of two things true?printthis:elseprintthis
2. logical and great for - if you want to do one thing else do nothing. true && execute this
3. can make a functional call {getLocation()} //if the value is undefined renders nothing

var user = {
    name: 'andy',
    age: 26,
    location: 'philly'
}
function getLocation(location) {
    if(location){
    return <p>location: {user.location}</p>
    }
}
var templateTwo = (
    <div>
       <h1> {user.name ? user.name.toUpperCase() : 'Anonymous'}</h1>
        {(user.age && user.age >= 18) && <p>{user.age}</p>}
        {getLocation(user.location)}
    </div>
)
Task:
1. only render the subtitle (and a p tag) if subtitle exists- logical AND operator
2. render new p tag - if options.length>0 "Here are you options" else "No options" - ternary
var app = {
    title: 'Indecision App',
    subTitle: 'Put your life in the hands of a computer',
    options: ['one', 'two']
}
var templateTwo = (
    <div>
        <h1>{app.title}</h1>
        {app.subTitle && <p>{app.subTitle}</p>}
       <p> {(app.options.length >0) ? 'Here are your options' : 'No options' }</p>
    </div>
)
J25
Const and let:
var - tons of code is in prod but creates some problems.
var name = 'srk'
name = 'mike'
console.log('name', name)

with var we can not only reassign a value but can re define 
var name = 'srk'
var name = 'mike'
console.log('name', name)
above statements are valid with var based variables. o/p is mike
overwriting the variable values and hence creates problems

let nameLet = 'srk'
nameLet = 'mike'
console.log(nameLet)
with let we can reassign a var but cannot redefine. error: duplicate declaration "nameLet" -es6

with const we cannot reassign or redefine variable values
const nameLet = 'srk'
nameLet = 'mike' //error
const nameLet = 'mike' //error
console.log(nameLet)

Scope:
var based variables are function scoped. cannot access var which is defined inside a func in outside of func.

function getPetName() {
    var petName = 'Hai';
    return petName
}
getPetName()
c.l(petName) //error. petName is not defined

let and const are also function scoped. will get the same error if we define same above func.
but they are also block level scoped

bound to code blocks - if statement, for loop

var fullName = 'React Javascript'
if(fullName){
    var firstName = fullName.split(' ')[0] //spliting string into array of strings and accessing   
                             //first index one
}
c.l(firstName)
var fullName and firstName are on same scope. we did not define func to change var variable scope
meaning you can access c.l(firstName) will get the output

if you define firstName variable as const or let, you will get error

if(fullName){
    let firstName = fullName.split(' ')[0] 
      c.l(firstName)
}
c.l(firstName) //error - firstName is not defined.

Arrow functions:
arrow functions are anonymous functions.
const squareArrow = (x) => x*x
we do not have to use return statement and {}, if we return only one expression.

details of arrow functions
1. do not bound arguments object
const add = function (a, b) {
    c.l(arguments)  //arguments object returns array of passed arguments
    return a + b
}
c.l(add(1,2,3)) //returns 3

but when we use arrow func, we get error for arguments statement. arguments is not defined

2. this keyword no longer bound when using arrow functions.

const user = {
    name: 'srk',
    cities: ['hyd','mumbai', 'pune']
    printPlacesLived: function() {
        //when you define a method inside a obj, this key is bound to that obj
        //can access this.name and this.cities

    this.cities.forEach(function (city) {
        c.l(this.name + ' has lived in '+ city)
    })
    }
}
when we run above program we get error as Type error: cannot read property 'name' of undefined

when you add a func on to an prop of obj, this value is bind to that obj
when you define a anonymous func, not bind this value, it is set to undefined

with es6 arrow func, your func no longer bind their own this value. instead they just use this
 value of the context that they were created in.

    func in forEach uses parent this value, here it is printPlacesLived , here this is obj.

const user = {
    name: 'srk',
    cities: ['hyd','mumbai', 'pune']
    printPlacesLived: function() {
    this.cities.forEach((city) => {    changed to arrow func. now this.name do not throw error
        c.l(this.name + ' has lived in '+ city)
    })
    }
}

for above ex, using of arrow func is adv. in some cases arrow func is not suitable
here if we use printPlacesLived prop func as arrow func we get error for this.cities as it will
not bind this keyword to the obj and will be mapped to global scope and here it is undefined

we can use es6 method 
const user = {
    name: 'srk',
    cities: ['hyd','mumbai', 'pune']
    printPlacesLived() { //cannot use arrow func here. use es6 new method definition syntax
    this.cities.forEach((city) => {    
        c.l(this.name + ' has lived in '+ city)
    })
    }
}

instead of forEach we can use map array method

forEach: run for each and every item of the array and do not return new array
 this.cities.forEach((city) => {    
        c.l(this.name + ' has lived in '+ city)
    })

map: creates a new array. does not affect this.cities array
const cityMessages = this.cities.map((city) => {    
        return this.city + ' has lived in ' + city
    })
c.l(cityMessages) -- ['cityone','cityTwo',..]

instead of creating cityMessages var just return it.

events and attributes
events - user interactions - button click
<button id="idone" class="button"><button>
error: unknown DOM property class, Did you mean className?
we cannot set attribute as class, class is a reserve keyword in Javascript. in JSX instead of class use className. Renamed
<button id="idone" className="button"><button>

let count = 0
const templateTwo = (
    <div>
        <h1>count: {count}</h1>
        <button id="someidhere"></button>
    </div>
)
c.l(templateTwo) --- return obj. children > h1 and p > className prop
google - react DOM elements. in html autofocus but in react dom autoFocus - camelCased

goal is to set up event listner
we can pass expression to id value
const someId = 'someIDhere'
let count = 0
const templateTwo = (
    <div>
        <h1>count: {count}</h1>
        <button id={someId}>+1</button>
    </div>
)

we can pass attribute as onClick which is an event and this event is triggered on user click.
define a function and refer it as value for the prop as jsx expression.

const addOne = () => {
    console.log('addOne')
}
const templateTwo = (
    <div>
        <h1>count: {count}</h1>
        <button onClick={addOne}>+1</button>
        <button onClick={minusOne}>-1</button> //define minusOne func.

    </div>
)
instead of referencing addOne variable name we can create function inside jsx expression. but if we have many function
readibility issue.

1. templateTwo only renders once, onClick method executes but templateTwo do not rerender. to re-render our 
template again we have to create a func and put templateTwo and ReactDOM.render() method in that func
so when a user click on button and a value changes we have to rerender our template here we just need to call the func which has templateTwo and ReactDOM.render()


const addOne = () => {
    count++
    rerenderApp()}
const minusOne = () => {
    count--
    rerenderApp()}
const reset = () => {
    count = 0
    rerenderApp()}

let count = 0
const rerenderApp = () => {
    const templateTwo = (
    <div>
        <h1>Count: {count}</h1>
        <button onClick={addOne}>+1</button>
        <button onClick={minusOne}>-1</button>
        <button onClick= {reset}>Reset</button>
        </div>)
 ReactDOM.render(templateTwo, appRoot)
}
var appRoot = document.getElementById('app')
rerenderApp()

Though the value count is updating when user click on +1 but our app is not rerendering the template. to rerender defining func with template and ReactDOM.render() func call and using this func where ever we want our app to rerender.

React virtual dom:
currently we are rendering whole page only for single value change i.e count 0 or 1

in ui - elements tab
if you change any dom element there will be animation shown.{flash animation says which element is changed}

we defined h1 element, count is static text and value is dynamic
react adds comments, react uses these comments

react uses virtual DOM algorithms in JS to determine changes made in app and renders only that part will be replaced or renders.

single piece of our app state changes like a number, we can rerender the app, updating the user without worrying about slowing down the user and not wasting the resources. virtual dom algo run behind the scenes this is done in js.
virtual dom calculates if any changes to be made, calculates min no.of changes hence efficient.

React.createElement() --returns obj represents our entire JSX tree , use algo to compare two objects. this is what react is doing. 

Forms and inputs:::
create a form 

var app = {
    title: 'Indecision App',
    subTitle: 'Put your life in the hands of a computer',
    options: []
}

const onFormSubmit = (e) => {
    e.preventDefault()
    const option = e.target.elements.inputform.value
    //target has element which user interacted. target obj has elements and we defined input element with name = inputform
    //we can access input form value from value attribute

    if(option) {    //checking if user enter entered anything in input form
        app.options.push(option)        //pushing user entered text to options array
        e.target.elements.inputform.value = ''  //setting input field to null after user entering text
        render()
    }
}
const render = () => {  //creating render method - using this to rerender ui. contains template and reactdom.render method
    var templateTwo = (
        <div>
            <h1>{app.title}</h1>
            {app.subTitle && <p>{app.subTitle}</p>}
            <p>{(app.options.length >0) ? 'Here are your options' : 'No options' }</p>
            {app.options.length} //displaying length count
            <ol>
                {app.options.map((option)=>{      //creating ol tag and creating li tags and displaying options array
                return <li key={option}>{option}</li> //we have to set key else throw error
                })}
            </ol>
            <form onSubmit={onFormSubmit}> //on submit we are calling onFormSubmit func.
                <input type="text" name="inputform"/>
                <button> Add option</button>
            </form>
        </div>
    )
    ReactDOM.render(templateTwo, appRoot)  
}

var appRoot = document.getElementById('app')
render()
Error: when you do not specify key :> Each child in a list should have a unique "key" prop.

JSX works with arrays.
{
    [11,22,33, null, undefined] //null and undefined are ignored by JSX. can put number,string , null but not object.
}

{
    [99,97, 96] - o/p 999796. jsx takes array and break it to ind peices. each peice has comments {react-text: 8} 
}

{<p>1</p>} - JSX in JSX.
{map{jsx}}
            <ol>
             {app.options.map((option)=>{
                return <li key={option}>{option}</li>
                })}
            </ol>

Now the task is to : ask computer to select a option. Two steps
create a button and do function call on clicking on it.

1. <button disabled={app.options.length === 0} onClick={selectOption}>what should I select?</button>
disabled={true/false} so we are checking if the length of array is 0, if yes disabled else display

2. const selectOption = () => {
    const randomNum = Math.floor(Math.random() * app.options.length)
    alert(app.options[randomNum])
    render()
}
we need random option so Math.random() gives random no. in b/w 0 - 0.999 we need to Multiply it with app.options items
if items 3 then 3 times 

Math.floor rounds the value. decimals values

re render the app -render()


Task 2: toggle button - show details - display some text and hide details.
create a variable visibility and set it to false. default one.

let visibility = false; 
const showDetails = () => {
    visibility = !visibility //flip the var value when user click on it
    render()
}
 <button onClick={showDetails}> //event handler onclick we call showDetails, which flips the value.
    { visibility ? 'Hide details' : 'Show details'} //default one is false so display show details
                                    //when user click on button we change button name to hide details
         </button>
         <p>{visibility && 'Education, Profile and native place'}</p> //if visibility true we display the text
    </div>

React Components: react uses Component based architecture
allows us to take our big complex app break them into small Components

Components - responsible for user profile, another one is usersignup file

Thinking in React:
twitter : Components

dashboard page - parent
children
<Header/>
<profileWidget/>
<Trends/>
    <Trend/>
<Tweet/>

Indecision APP:
<IndecisionApp/>
<Header/>
<Action/>
<options/>
    <option/>
<Addoption/>

J27
Es6 classes:
goal is to use classes to reuse code. define a class like blueprint, we can create multiple instances using that blue print
ex: skyscapper blue print we can construct 7 building exact same skyscapper-same features also extra features. unique features like address of the building.

Car class, many instances of the Car - each data will be specific to that car.
make
model
vin 
getDescription() -- return a string description, like you are looking a used car of some model.
getDescription can be accessed in all of the instances. resuable one

Person class, each Person has unique attributes among them but also few things are also same. 
class Person {  --class is a reserve keyword in JS. Person is a className
        //define our class. not a if/for/func body
}
make a instance of class Person
we use new keyword to make new instance of a class. tell js that we are making instance.
const me = new Person()
console.log(me)

o/p: Person {}
instance of Person. also empty object - this object is specific to Person instance.if it is car instance, it will have make model and vin specific to car instance

Pass in data to instance. we can pass string number boolean or objects and as many as you can to the instance.
passing string

const me = new Person('srk')
unique to this instance. 
o/p is same Person {} because we are passing data but are not using it.

Define the constructor func for the Person class
constructor func gets called when we make a new instance and gets called with all the arguments passed.

class Person{
    constructor(name) {     //es6 method definition syntax
        console.log('test')
    }
}
const me = new Person('srk')
o/p - 
test
Person {}
because when we use new Person{} , constructor func gets executed.

No data is showing up, we have to customize, not a Person class as a whole but the individual instance of the Person

inside of class methods we have access to this. " 'this' refers to class instance "

class Person{
    constructor(name) { 
        this.name = name //own understanding - this.name is equal to me.name {me - instance} and assigning name value'srk' 
    }
}
const me = new Person('srk')

we can create as many instances as we like. 
const newperson = new Person('abd')

also we can pass multiple arguments and also can set default values
below ex: 1. two arguments, 2. setting default value to age as 0, if the new instance do not pass age we set it to 0.

class Person{
    constructor(name, age=0) { 
        this.name = name 
        this.age = age
    }
}
const me = new Person('srk', 26) o/p = Person {name:'srk', age:26}
const newperson = new Person('abd') o/p= Person {name:"abd", age:undefined}

setup a method that can be used in every instance of a Person
class Person{
    constructor(name, age=0) {  //implicitly called
        this.name = name 
        this.age = age
    }
//can define custom methods and are explicitly called
//methods are available to us in individual instances of the class

    getGreeting() {
        //return 'hi'     //call it in instance. me.getGreeting() return string 'hi'
//inside this method we have access to 'this' which is current instance

        return `${this.name} is a student and has age ${this.age}`
                    //o/p - srk is a student and has age 26
                    ****getGreeting is a method which is accessible in all the instances of Person class.
                    //o/p2 - abd is a student and has age 0.

    }
}
creating a sub class of a Person class:
Person and sub class is a Student

we realized that Student is also a Person with some modifications. Person has name and age and student indeed has name and age. student has also a major which we want to track of.

instead of copying and pasting the code from Person class we can just extend Person class in Student

class Student extents Person{ 
    //extends gives us all of the functionalities of Person and also allows us to override any of the functionalities of Person
}
const me = new Student('srk',26)
c.l(me.getGreeting()) --o/p srk is a student and has age 26
getGreeting is defined in Person but is also accessible in Student instance

above we created empty class Student. now we do something useful
1. setup constructor func to take new info ex here: major

const me = new Student('srk',26, 'computer science')
c.l(me)
o/p Student {name:'srk',age:26}
computer science is not visible because we did not use it in Student class. define constructor func and use major argument
we also need age and name which are defined under Person class. how do we access age and name from Person class in Student class? we need to override Person class
Ans: using super() method

class Student extends Person{ 
    constructor(name, age, major) { //arguments passed while creating instance
    
    question: do we have to set default values to name and age {which we did in Person class} and do we have to configure their properties? ans No 
    we have to call parent constructor to do its thing  {configuring name and age }
    and then we need to do our thing {configuring major}


    super(name, age) 
    //super refers to parent class here Person andif we call it as func,we are accessing constructor func of Person
    //call it with correct data name and age. Person class will take care of defaults and all
    this.major = major;

    }   
}
const me = new Student('srk',26, 'computer science')
c.l(me)
o/p: Student {name: 'srk', age: 26, major: 'computer science'}
const me = new Student('abd',26)
o/p: Student {name: 'srk', age: 26, major: undefined}


we can add new methods to Student class

class Student extents Person{ 
    constructor(name, age, major) { 
    super(name, age) 
    this.major = major;
    }  
    hasMajor() {
        // '' ==> false. !'' = true {flipping false to true}. !!'' == false {take false>true>false}
        // !!undefined ==> {false>true>false}
        //because we get Major as undefined if we do not use while creating a instance

        return !!this.major --'this' is instance and the value will be string or undefined --> {undefined -false>true>false}
        {string - true>false>true}
    
    } 
}
const me = new Student('srk',26, 'computer science')
c.l(me.hasMajor())
o/p: true
const other = new Student()
c.l(other.hasMajor()) -- false

Now that we have seen tack on new data and new methods {major string and hasMajor method}
also we know how to access data from parent
but
How do we override parent data?

override getDescription() method:
1. 
class Student extents Person{ 
    constructor(name, age, major) { 
    super(name, age) 
    this.major = major;
    }  
    hasMajor() {
        return !!this.major
    } 

    getDescription(){
        return 'testing'
    }
}

const me = new Student('srk',26, 'computer science')
c.l(me.getDescription(())
o/p: testing
getDescription method is also there in parent - Person class. we completly overridden the method in child - Student class
hence ouptut is testing string

2. instead of completly overridding the parent func we can use it in child and customize it based on child need

class Student extends Person{ 
    constructor(name, age, major) { 
    super(name, age) 
    this.major = major;
    }  
    hasMajor() {
        return !!this.major
    } 
    getDescription(){
        //creating a variable to store parent func return value
        //super() calls parent constructor. we need methods of parent so super.methodName

        let description = super.getDescription()
        //description var stores return value from getDescription() method of parent.

        //will add text, if the student has major add it to this func return value

        if(this.hasMajor()) //we are accessing instance so this
        {
             description = description + `has major in ${this.major}` //appending text to returned text from parent
        }
        return description

    }
}

const me = new Student('srk',26, 'computer science')
c.l(me.getDescription(())

o/p: srk is 26 years and has major in computer science
const other = new Student()
c.l(other.getDescription())

o/p: unknown is 0 years old {defined defaults name= unknown, age=0 }

Creating a React Component:
clear app.js file. creating Header Component

react Component is just a es6 class. goal is to take in es6 class and convert it to Component by extending something whcih is given by react. global React and global ReactDOM.
Access Component class from React object
Now Header gets all of the features of react

imp: React Component require one method to be defined. this is a special method that it calls. i.e render()
with es6 it is ok not to define methods but in react Component you must define render

render takes no arguments. returns JSX

class Header extends React.Component {
    render() {
        return <p>This is from Header Component</p>
    }
}
Above is perfectly valid react Component

To render in dom, use ReactDOM.render()
define jsx:

const jsx = (
    <div>
        <p> this is some title</p> {instead of using elements we can use react Components that we created and render them}
        <Header /> {Component name which looks like html} --this will get render
        <Header />
        <Header /> {react Components are resuable } 3instances of Header Component, no need of writing them again
    </div>
)
ReactDOM.render(jsx, document.getElementById('app'))

for es6 class name Header or header is fine, capital letter is just a convention where as in React Component

if we write header it treats as html. react differentiates html and react Component with capitalization Header - Component
and header is html

if we write <header/> instead of <Header /> , in React.createElement('header', null) assumes <header/>as html
where as if we use <Header /> , React.createElement(Header, null) , it refers to to the Component / header class 

so initial capital letter is important in React

class Action extends React.Component {
    render() {
        return ( instead of returning single jsx we can return multiple by creating root div element
            <div>
                <button>What should I do? </button>
            </div>
        )
    }
}
call this Action in JSX. in ui we are getting data from Components.
J28
Nesting Components: one component can render another component

Parent Component -Indecision, child Components - Header,Action,Options and Addoption
class IndecisionApp extends React.Component{
    it has child Components - Header,Action,Options and Addoption
}
Options has child option
remove jsx
 const jsx = (
    <div>
    <Header />
    <Action />
    <Options />
    <Addoptions />
    </div>
)

Instead of writing JSX we can directly pass Component to ReactDOM.render(<IndecisionApp/>, documentbyid(''))

Task : create option component under options 
class Options extends React.Component {
    render(){
        return {
            <div>
                <Option /> create Option component and pass it here.
            </div>
        }
    }
}
can write component name as <Option><Option/> or <Option/>

Component Props: allows components to communicate with one another.
ex: Header component currently is static. where ever we use the instance of Header component we get the same static data
but we need header to change in each page ex: About page, Profile page etc

In order to do that, Pass data in when we intilialize the instance of the component. that data is called Props
similar like html attributes key value pairs

<Header title="test value"/>

We passed data to header component. How can we access this title data in Header component?
inside our component we have access to this {under render method}. 'this' is reference to current instance of the component. reacts gives us access to our props on a object this.props

c.l(this.props)
o/p: Object{title: "test value"}

coverts title="test value" to Object {title: "value", object is props}

can access title value as <h1>{this.props.title}</h1>

in Indecision component we are passing title=value, this value we can pass from a variable defined else where

class Indecision extends React.Component{
    render(){
        const title = 'Indecision'
        const subTitle = 'Put your life in hands of a computer'
        return {
            <Header title={title} subTitle={subTitle} /> //passing data to instance of header, when this header component try to render 
            //component has access to the values passed via props. this.props
        }
    }
}
this.props is a object with the properties passed

we successfully passed title and subTitle as props to Header component and rendered those props in Header comp.

Now the goal is to create a variable options =['','',''] and pass it to Options component, this Options component then
sends data to Option component where it renders each/individual option.

Task : 
setup options prop for Options component
render the length of the array

1. In the Indecision component create var const options = ['','',''] and pass it to Options component
    const options = ['Thing one','Thing two','Thing three']
     <Options options={options}/>
2. Access this passed props in Options Component and get the length    
    <p>{this.props.options.length}</p>

Instead of rendering length we can render the items in array as individual p tags in Options component
<div>
     {this.props.options.map((option)=>{
     return <p key={option}>{option}</p>
    })}        
</div>

if you do not specify key attribute, you will get an error as "Each child in a list should have a unique "key" prop

==> instead of rendering paragraphs we can render instance of Option

implicitly return instance of Option
if we are creating a array of JSX we have to define a key on each whether it is li,p or component
key is reserved name

optionText={option}
access this props optionText in Option component


Options component:
<div>
    {this.props.options.map((option)=>{
    return <Option key={option} optionText={option}/>
     })}        
</div>

Option component:
<div>
    Options: {this.props.optionText}
</div>
Adv: components are super flexible and super resuable.


Imp: 
1. when we create instance of component we can also choose to pass data into it. key={value} array
2. when we pass data to component we can access passed data inside the component,via this.props
this gave us to setup one way communication. IndecisionApp component can communicate some information with Header, Action
Components. Opions can communicate some information with Option.
Above ex's create one way communication

what if when user use AddOption to add an option and we want that data in IndecisionApp component to insert/update Options array? {two way to communication? till now parent is sending info to child and we need also child to send info to parent}

event and methods:
event handlers:
do something on button click. we know onClick={ref func}

earlier we created global func ex: onFormSubmit, onRemoveAll. now we create class methods {like es6 class methods}

class Action extends React.Component{
    handlePick(){                   //create a func. it does something on button click
        alert('handle pick')
    }
    render() {
        return (
            <div>
                <button onClick={this.handlePick}>What should I do?</button> 
                //this.handlePick --> this is component class instance
                //ref the func do not call it. it gets called on ///button click
            </div>
        )
    }
}

Task1: Add button to action component. remove all button. setup handleRemoveAll method and onClick method {same as handlePick methods}

Task2: we need to create a form in AddOption component, input field and submit button. onSubmit call a method
define handleAddOption method. 1. fetch the value typed 2. if typed then alert

class Addoptions extends React.Component {
    handleFormSubmit(e){
        e.preventDefault()
        const option = (e.target.elements.addoption.value.trim())
        if(option) {
            alert(option)
        }
    }
    render() {
        return (
            <div>
                <form onSubmit={this.handleFormSubmit}>
                <input type="text" name="addoption"/>
                <button>Submit</button>
                </form>
            </div>
        )
    }
}

Method binding: this binding

class Options extends React.Component {
    handleRemoveAll() {
        console.log(this) //error
        console.log(this.props.options) //error - uncaught type error: Cannot read property 'props'of null
        console.log('check where is this keyword pointing to')
        // alert('handle remove all')
    }
    render() {
        return (
            <div>
                <button onClick={this.handleRemoveAll}>RemoveALL</button>
                {this.props.options.map((option)=>{
                    return <Option key={option} optionText={option}/>
                })}        
             </div>
        )
    }
}
in es6 class ex, methods are bound to class instances. we are able to access the data this.major inside major method 

Options class has handleRemoveAll and render methods. for render method we are able to access this binding. this.handleRemoveAll works

but we broken the this binding for handleRemoveAll() method, in handleRemoveAll() method
        console.log(this) //error
        console.log(this.props.options) //error - uncaught type error: Cannot read property 'props'of null
trying to access props on 'this' which is undefined hence getting error

we are clearly losing the this binding. 'this' no longer refers to our class instance
myunderstanding: when we reference a func which is defined under a obj we break the this binding
EX:
 const obj ={
    name: 'vikky',
    getName() {
        return this.name;
    }
}
c.l(obj.getName()) //o/p -- vikky
this binding is working fine. above is similar to es6 class

const getName = obj.getName
c.l(getName())
o/p - instead of seeing vikky we are getting uncaught typeerror cannot read property of 'name' of undefined.

when we create getName we are referencing obj.getName, both are running same code. context it ran is different.
obj.getName is in context of an obj so we have access to the object with this binding.
but when we break it into func we actually loose the context, the context is not get transferred.

Now we just have regular function. regular func have undefined for their this by default

const func = function () {
    console.log(this)
}
func()
o/p: undefined

{afz once told me that obj.getName -- where ever the func get called, this key word points to that obj {here obj.getName - getName this is pointing to obj}

we need to figure out how we can set the this binding, we do it by using .bind() method available on a function in JS.

{this binding in handleRemoveAll() is undefined. normal func this binding is undefined. we need to set the this binding}

const obj ={
    name: 'vikky',
    getName() {
        return this.name;
    }
}
const getName = obj.getName
//bind is accessible on a func. here getName is a func so add .bind and call it, when we call it we get our func back 
which means obj.getName and obj.getName.bind() are same

cool thing abt bind is, you can use first argument to set this context, we can set it to equal to obj. this brngs back context what we expect

const obj ={
    name: 'vikky',
    getName() {
        return this.name;
    }
}
const getName = obj.getName.bind(obj)
c.l(getName())
o/p: vikky

we can pass obj or inline obj {name: 'abd'} by doing this we forced 'this' context of const getName function to be the inline object to use the name returns abd instead of vikky.

we loose this binding in event handlers also in some places eventhandlers of js so we use can this binding

mdn bind - we are using it for reset the context

Implement this in our program:
goal is to able to log out the options array inside handleRemoveAll func

a. <button onClick={this.handleRemoveAll}>RemoveALL</button>

we referenced handleRemoveAll and this gets called on later, here breaks this binding we can call .bind.
render is not a eventhandler and has a correct this binding. able to access this.props and this.handleRemoveAll

b. <button onClick={this.handleRemoveAll.bind(this)}>RemoveALL</button>

we set .bind(this) this makes the this context for handleRemoveAll and render() has exact same.

technique defined above works .bind(this) but is inefficient. It requires us to rerun bind everytime component rerenders we do it often.
 
instead we can override the constructor function for React.component, 

1.step 1 create a constructor

constructor(props) { //gets called with props obj same as this.props in render method
    super(props)        
    //we need to make sure that we dont break anything, we call super with props. if we dont use super
    //(props) we do not have access to this.props

    //if you want to overide constructor func we need to use above two steps. yet, it doesnot add on any behavoir
    //goal is to bind handleRemoveAll
        //setting the value
    this.handleRemoveAll = this.handleRemoveAll.bind(this)
    //constructor func is not a eventhandler so the this context is correct by default.

    //by doing above, we are making sure whatever we call handleRemoveAll the context is correct. if we use handleRemoveAll for multiple times 1. we dont have to type .bind() calls multiple times and 2. it just runs binding once when the component runs not need to rebound everytime component Renders
}

o/p: gets the array
class Options extends React.Component {
    constructor (props) {
        super(props)
        this.handleRemoveAll = this.handleRemoveAll.bind(this)
    }

    handleRemoveAll() {
        console.log(this.props.options)
        console.log('check where is this keyword pointing to')
        // alert('handle remove all')
    }
    render() {
        return (
            <div>
                <button onClick={this.handleRemoveAll}>RemoveALL</button>
                {this.props.options.map((option)=>{
                    return <Option key={option} optionText={option}/>
                })}        
             </div>
        )
    }
}

setting up our react components to render data have real time binding so when the data changes automatically rerenders the UI.

component state: allows our components to manage data
think about an obj with various key value pairs. and when that data changes the component will automatically rerender to
reflect those changes.

without state, we you change the array we have to manually call rerender {ex: JSX we used earlier for counter app}
with component state all we have to manipulate the data, component gonna take care of rerender itself

ex:
component counter:
earlier we created and manipulated count variable.

1. <Counter />
2. default set of values. default state value. in case of react component we use obj

default state obj
{
    count: 0
}

3. our component rerenders itself for first time with default value. in UI count: 0
we never call render manually, 
4. user clicked on plus button, handlePlusOne method executed and increase count by 1
{
    count:1
}
change state based on event

{button click or network request to fetch some data}

5. application rerender itself it brings ui with up to date with component state. ui count: 1

we just chnaged the state, react component sees the change and updates UI


Building counter app using component state:
1. set up a default state object 
oick all of the state properties we need, here count: 0
how to setup default state obj?
this happen inside constructor func. is similar to es6 ex setting up name and age properties. this.name = name

this.state = {  //obj, we deinfe all the pieices of state that we want, here just count
    count: 0
}

2. render that to screen

<h1>count: {this.state.count} </h1>
this.state is a object and can't write obj directly {remember} , access count property
Count: 0 is shown

3. change the state based on event
add or plus one

we know that this.state is a object. we are trying to update the state, we do not just update that obj. it is not gonna work
handleOne(){
    this.state.count = this.state.count + 1
    console.log(this.state)
}

o/p: Object {count:1}
Object {count:2}
Object {count:3}

count is updating but our component is not rerendering itself. when we are working with class based components if we want to change the state we do not manually update the obj instead we call a method on component instance

setState allows us to manipulate state object. it is a func. after updating the state our component rerenders automatically. gets called with one argument which is a func. in this func we gonna define the updates we wanna make
how do we gonna define those updates? we just return the object, we specify various state values that we wanna change and new values that we want to assigne
we change count here

this.setState(()=>{
    return {
        count: 1
    }
})

count should go to 1 on clicking on +1. state is getting manipulated and we are refreshing the component

inside of setState we have access to current state values via the first argument commonly called prevState - our state object before tyur changes applied

this.setState((prevState)=>{
    return {
        count: prevState.count + 1 //current count plus one. multiple clicks on +1 , increases count and refreshes screen
    }
})

similarly do for handleMinusOne and handleReset.

if you have multiple pieces of state on your component. you do not have to provide them all in setState. you just updated 
what you need/want to change

this.state{
    count: 0,
    name: 'vikky'
}

this.setState((prevState)=>{
    return {
        count: prevState.count + 1
    }
})
observe count value changes on clicking on +1. not that using this.setState we are changing/overridding the state completly. Just changing specific values here count.

Alternate setState syntax:
instead of passing func to this.setState, earlier version we can pass obj directly.

this.setState({
    count:1
})
but when we have two this.setState(), we do not do it single component but multiple func can trigger at same time
 this.setState({
    count: this.state.count + 1
})
this.setState({
    count:0
})
 this.setState({
    count: this.state.count + 1 //no prevState as we are not using cb
})
so the expected o/p will be 1 when you click on 14 times but it prints 15. setState is asynchronous 

when you start the process of changing count:0 it doesnot mean the count value should be updated in very next line
thats y we get this.state.count old value hence old value plus one. started the process to set count to 0 but is not finished.

lot of scenes going on while updating the obj. react merge old state obj with new one then it creates virtual dom and does the changes. 

we will end up with the results that we did not expect.

Will do same with 
this.setState(()={
    return {
        count: 0
    }
})
this.setState((prevState)={
    return {
        count: prevState + 1
    }
})
we defined above methods on handleReset(), on clicking on reset we will get the o/p as 1.correct

How?
first func - react starts executing it, while it is processing, before finishing it, before rerendering , it sees another setState and sees any changes to state so it figures out, out of two, which one should I pick up

figures out what need to change. passes new state {prevState} to second func.

***Task: Adding state to visibility toggle
class VisibilityToggle extends React.Component{
    constructor(props){
        super(props)
        this.handleToggleVisibility = this.handleToggleVisibility.bind(this)
        this.state = {
            visibility : false
        }
    }
    handleToggleVisibility() {
        this.setState((prevState)=>{
            return {
                visibility: !prevState.visibility
            }
        })
    }
    render(){
        return (
            <div>
                <h1>Visibility Toggle</h1>
             <button onClick ={this.handleToggleVisibility}>{this.state.visibility ? 'Hide details' : 'Show Details'}</button>
        <p>{this.state.visibility && 'Profile, Education and Location'}</p>
            </div>
        )
    }
}
ReactDOM.render(<VisibilityToggle />, document.getElementById('app'))

Indecision state:
class IndecisionApp extends React.Component {
    render() {
        const title = 'Indecision'
        const subTitle = 'Put your life in the hands of a computer'
        const options = ['Thing one','Thing two','Thing three',' Thing four']
        return (
            <div>
                <Header title={title} subTitle={subTitle} />
                <Action />
                <Options options={options}/>
                <Addoptions />
            </div>
        )
    }
}
class Header extends React.Component {
    render() {
        return (
            <div>
                <h1>{this.props.title}</h1>
                <h2>{this.props.subTitle}</h2>
            </div>
        )
    }
}

*** passing title value to Header component via Props from IndecisionApp component






















